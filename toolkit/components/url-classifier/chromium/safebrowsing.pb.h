// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#ifndef PROTOBUF_safebrowsing_2eproto__INCLUDED
#define PROTOBUF_safebrowsing_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace mozilla {
namespace safebrowsing {
class Checksum;
class ChecksumDefaultTypeInternal;
extern ChecksumDefaultTypeInternal _Checksum_default_instance_;
class ChromeClientInfo;
class ChromeClientInfoDefaultTypeInternal;
extern ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
class ClientInfo;
class ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class Duration;
class DurationDefaultTypeInternal;
extern DurationDefaultTypeInternal _Duration_default_instance_;
class FetchThreatListUpdatesRequest;
class FetchThreatListUpdatesRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest;
class FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
class FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
class FetchThreatListUpdatesResponse;
class FetchThreatListUpdatesResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_default_instance_;
class FetchThreatListUpdatesResponse_ListUpdateResponse;
class FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
class FindFullHashesRequest;
class FindFullHashesRequestDefaultTypeInternal;
extern FindFullHashesRequestDefaultTypeInternal _FindFullHashesRequest_default_instance_;
class FindFullHashesResponse;
class FindFullHashesResponseDefaultTypeInternal;
extern FindFullHashesResponseDefaultTypeInternal _FindFullHashesResponse_default_instance_;
class FindThreatMatchesRequest;
class FindThreatMatchesRequestDefaultTypeInternal;
extern FindThreatMatchesRequestDefaultTypeInternal _FindThreatMatchesRequest_default_instance_;
class FindThreatMatchesResponse;
class FindThreatMatchesResponseDefaultTypeInternal;
extern FindThreatMatchesResponseDefaultTypeInternal _FindThreatMatchesResponse_default_instance_;
class ListThreatListsResponse;
class ListThreatListsResponseDefaultTypeInternal;
extern ListThreatListsResponseDefaultTypeInternal _ListThreatListsResponse_default_instance_;
class RawHashes;
class RawHashesDefaultTypeInternal;
extern RawHashesDefaultTypeInternal _RawHashes_default_instance_;
class RawIndices;
class RawIndicesDefaultTypeInternal;
extern RawIndicesDefaultTypeInternal _RawIndices_default_instance_;
class RiceDeltaEncoding;
class RiceDeltaEncodingDefaultTypeInternal;
extern RiceDeltaEncodingDefaultTypeInternal _RiceDeltaEncoding_default_instance_;
class ThreatEntry;
class ThreatEntryDefaultTypeInternal;
extern ThreatEntryDefaultTypeInternal _ThreatEntry_default_instance_;
class ThreatEntryMetadata;
class ThreatEntryMetadataDefaultTypeInternal;
extern ThreatEntryMetadataDefaultTypeInternal _ThreatEntryMetadata_default_instance_;
class ThreatEntryMetadata_MetadataEntry;
class ThreatEntryMetadata_MetadataEntryDefaultTypeInternal;
extern ThreatEntryMetadata_MetadataEntryDefaultTypeInternal _ThreatEntryMetadata_MetadataEntry_default_instance_;
class ThreatEntrySet;
class ThreatEntrySetDefaultTypeInternal;
extern ThreatEntrySetDefaultTypeInternal _ThreatEntrySet_default_instance_;
class ThreatHit;
class ThreatHitDefaultTypeInternal;
extern ThreatHitDefaultTypeInternal _ThreatHit_default_instance_;
class ThreatHit_ThreatSource;
class ThreatHit_ThreatSourceDefaultTypeInternal;
extern ThreatHit_ThreatSourceDefaultTypeInternal _ThreatHit_ThreatSource_default_instance_;
class ThreatHit_UserInfo;
class ThreatHit_UserInfoDefaultTypeInternal;
extern ThreatHit_UserInfoDefaultTypeInternal _ThreatHit_UserInfo_default_instance_;
class ThreatInfo;
class ThreatInfoDefaultTypeInternal;
extern ThreatInfoDefaultTypeInternal _ThreatInfo_default_instance_;
class ThreatListDescriptor;
class ThreatListDescriptorDefaultTypeInternal;
extern ThreatListDescriptorDefaultTypeInternal _ThreatListDescriptor_default_instance_;
class ThreatMatch;
class ThreatMatchDefaultTypeInternal;
extern ThreatMatchDefaultTypeInternal _ThreatMatch_default_instance_;
}  // namespace safebrowsing
}  // namespace mozilla

namespace mozilla {
namespace safebrowsing {

namespace protobuf_safebrowsing_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_safebrowsing_2eproto

enum FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED = 0,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE = 1,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE = 2
};
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value);
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
const int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX + 1;

enum ThreatHit_ThreatSourceType {
  ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED = 0,
  ThreatHit_ThreatSourceType_MATCHING_URL = 1,
  ThreatHit_ThreatSourceType_TAB_URL = 2,
  ThreatHit_ThreatSourceType_TAB_REDIRECT = 3,
  ThreatHit_ThreatSourceType_TAB_RESOURCE = 4
};
bool ThreatHit_ThreatSourceType_IsValid(int value);
const ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MIN = ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
const ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MAX = ThreatHit_ThreatSourceType_TAB_RESOURCE;
const int ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE = ThreatHit_ThreatSourceType_ThreatSourceType_MAX + 1;

enum ChromeClientInfo_SafeBrowsingReportingPopulation {
  ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED = 0,
  ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT = 1,
  ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED = 2,
  ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT = 3
};
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value);
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN = ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX = ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
const int ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE = ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX + 1;

enum ThreatType {
  THREAT_TYPE_UNSPECIFIED = 0,
  MALWARE_THREAT = 1,
  SOCIAL_ENGINEERING_PUBLIC = 2,
  UNWANTED_SOFTWARE = 3,
  POTENTIALLY_HARMFUL_APPLICATION = 4,
  SOCIAL_ENGINEERING = 5,
  API_ABUSE = 6,
  MALICIOUS_BINARY = 7,
  CSD_WHITELIST = 8,
  CSD_DOWNLOAD_WHITELIST = 9,
  CLIENT_INCIDENT = 10,
  SUBRESOURCE_FILTER = 13
};
bool ThreatType_IsValid(int value);
const ThreatType ThreatType_MIN = THREAT_TYPE_UNSPECIFIED;
const ThreatType ThreatType_MAX = SUBRESOURCE_FILTER;
const int ThreatType_ARRAYSIZE = ThreatType_MAX + 1;

enum PlatformType {
  PLATFORM_TYPE_UNSPECIFIED = 0,
  WINDOWS_PLATFORM = 1,
  LINUX_PLATFORM = 2,
  ANDROID_PLATFORM = 3,
  OSX_PLATFORM = 4,
  IOS_PLATFORM = 5,
  ANY_PLATFORM = 6,
  ALL_PLATFORMS = 7,
  CHROME_PLATFORM = 8
};
bool PlatformType_IsValid(int value);
const PlatformType PlatformType_MIN = PLATFORM_TYPE_UNSPECIFIED;
const PlatformType PlatformType_MAX = CHROME_PLATFORM;
const int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

enum CompressionType {
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  RAW = 1,
  RICE = 2
};
bool CompressionType_IsValid(int value);
const CompressionType CompressionType_MIN = COMPRESSION_TYPE_UNSPECIFIED;
const CompressionType CompressionType_MAX = RICE;
const int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

enum ThreatEntryType {
  THREAT_ENTRY_TYPE_UNSPECIFIED = 0,
  URL = 1,
  EXECUTABLE = 2,
  IP_RANGE = 3,
  CHROME_EXTENSION = 4,
  FILENAME = 5,
  CERT = 6
};
bool ThreatEntryType_IsValid(int value);
const ThreatEntryType ThreatEntryType_MIN = THREAT_ENTRY_TYPE_UNSPECIFIED;
const ThreatEntryType ThreatEntryType_MAX = CERT;
const int ThreatEntryType_ARRAYSIZE = ThreatEntryType_MAX + 1;

// ===================================================================

class ThreatInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatInfo) */ {
 public:
  ThreatInfo();
  virtual ~ThreatInfo();

  ThreatInfo(const ThreatInfo& from);

  inline ThreatInfo& operator=(const ThreatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatInfo(ThreatInfo&& from) noexcept
    : ThreatInfo() {
    *this = ::std::move(from);
  }

  inline ThreatInfo& operator=(ThreatInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatInfo& default_instance();

  static inline const ThreatInfo* internal_default_instance() {
    return reinterpret_cast<const ThreatInfo*>(
               &_ThreatInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ThreatInfo* other);
  friend void swap(ThreatInfo& a, ThreatInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatInfo& from);
  void MergeFrom(const ThreatInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  int threat_types_size() const;
  void clear_threat_types();
  static const int kThreatTypesFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_types(int index) const;
  void set_threat_types(int index, ::mozilla::safebrowsing::ThreatType value);
  void add_threat_types(::mozilla::safebrowsing::ThreatType value);
  const ::google::protobuf::RepeatedField<int>& threat_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_threat_types();

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  int platform_types_size() const;
  void clear_platform_types();
  static const int kPlatformTypesFieldNumber = 2;
  ::mozilla::safebrowsing::PlatformType platform_types(int index) const;
  void set_platform_types(int index, ::mozilla::safebrowsing::PlatformType value);
  void add_platform_types(::mozilla::safebrowsing::PlatformType value);
  const ::google::protobuf::RepeatedField<int>& platform_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_platform_types();

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  int threat_entries_size() const;
  void clear_threat_entries();
  static const int kThreatEntriesFieldNumber = 3;
  const ::mozilla::safebrowsing::ThreatEntry& threat_entries(int index) const;
  ::mozilla::safebrowsing::ThreatEntry* mutable_threat_entries(int index);
  ::mozilla::safebrowsing::ThreatEntry* add_threat_entries();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >*
      mutable_threat_entries();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >&
      threat_entries() const;

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  int threat_entry_types_size() const;
  void clear_threat_entry_types();
  static const int kThreatEntryTypesFieldNumber = 4;
  ::mozilla::safebrowsing::ThreatEntryType threat_entry_types(int index) const;
  void set_threat_entry_types(int index, ::mozilla::safebrowsing::ThreatEntryType value);
  void add_threat_entry_types(::mozilla::safebrowsing::ThreatEntryType value);
  const ::google::protobuf::RepeatedField<int>& threat_entry_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_threat_entry_types();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> threat_types_;
  ::google::protobuf::RepeatedField<int> platform_types_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry > threat_entries_;
  ::google::protobuf::RepeatedField<int> threat_entry_types_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatMatch : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatMatch) */ {
 public:
  ThreatMatch();
  virtual ~ThreatMatch();

  ThreatMatch(const ThreatMatch& from);

  inline ThreatMatch& operator=(const ThreatMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatMatch(ThreatMatch&& from) noexcept
    : ThreatMatch() {
    *this = ::std::move(from);
  }

  inline ThreatMatch& operator=(ThreatMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatMatch& default_instance();

  static inline const ThreatMatch* internal_default_instance() {
    return reinterpret_cast<const ThreatMatch*>(
               &_ThreatMatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ThreatMatch* other);
  friend void swap(ThreatMatch& a, ThreatMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatMatch* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatMatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatMatch& from);
  void MergeFrom(const ThreatMatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
  bool has_threat() const;
  void clear_threat();
  static const int kThreatFieldNumber = 3;
  const ::mozilla::safebrowsing::ThreatEntry& threat() const;
  ::mozilla::safebrowsing::ThreatEntry* mutable_threat();
  ::mozilla::safebrowsing::ThreatEntry* release_threat();
  void set_allocated_threat(::mozilla::safebrowsing::ThreatEntry* threat);

  // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
  bool has_threat_entry_metadata() const;
  void clear_threat_entry_metadata();
  static const int kThreatEntryMetadataFieldNumber = 4;
  const ::mozilla::safebrowsing::ThreatEntryMetadata& threat_entry_metadata() const;
  ::mozilla::safebrowsing::ThreatEntryMetadata* mutable_threat_entry_metadata();
  ::mozilla::safebrowsing::ThreatEntryMetadata* release_threat_entry_metadata();
  void set_allocated_threat_entry_metadata(::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata);

  // optional .mozilla.safebrowsing.Duration cache_duration = 5;
  bool has_cache_duration() const;
  void clear_cache_duration();
  static const int kCacheDurationFieldNumber = 5;
  const ::mozilla::safebrowsing::Duration& cache_duration() const;
  ::mozilla::safebrowsing::Duration* mutable_cache_duration();
  ::mozilla::safebrowsing::Duration* release_cache_duration();
  void set_allocated_cache_duration(::mozilla::safebrowsing::Duration* cache_duration);

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_type() const;
  void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  ::mozilla::safebrowsing::PlatformType platform_type() const;
  void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 6;
  ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatMatch)
 private:
  void set_has_threat_type();
  void clear_has_threat_type();
  void set_has_platform_type();
  void clear_has_platform_type();
  void set_has_threat_entry_type();
  void clear_has_threat_entry_type();
  void set_has_threat();
  void clear_has_threat();
  void set_has_threat_entry_metadata();
  void clear_has_threat_entry_metadata();
  void set_has_cache_duration();
  void clear_has_cache_duration();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mozilla::safebrowsing::ThreatEntry* threat_;
  ::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata_;
  ::mozilla::safebrowsing::Duration* cache_duration_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindThreatMatchesRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FindThreatMatchesRequest) */ {
 public:
  FindThreatMatchesRequest();
  virtual ~FindThreatMatchesRequest();

  FindThreatMatchesRequest(const FindThreatMatchesRequest& from);

  inline FindThreatMatchesRequest& operator=(const FindThreatMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindThreatMatchesRequest(FindThreatMatchesRequest&& from) noexcept
    : FindThreatMatchesRequest() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesRequest& operator=(FindThreatMatchesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindThreatMatchesRequest& default_instance();

  static inline const FindThreatMatchesRequest* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesRequest*>(
               &_FindThreatMatchesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FindThreatMatchesRequest* other);
  friend void swap(FindThreatMatchesRequest& a, FindThreatMatchesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindThreatMatchesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FindThreatMatchesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FindThreatMatchesRequest& from);
  void MergeFrom(const FindThreatMatchesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 1;
  const ::mozilla::safebrowsing::ClientInfo& client() const;
  ::mozilla::safebrowsing::ClientInfo* mutable_client();
  ::mozilla::safebrowsing::ClientInfo* release_client();
  void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
  bool has_threat_info() const;
  void clear_threat_info();
  static const int kThreatInfoFieldNumber = 2;
  const ::mozilla::safebrowsing::ThreatInfo& threat_info() const;
  ::mozilla::safebrowsing::ThreatInfo* mutable_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* release_threat_info();
  void set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindThreatMatchesRequest)
 private:
  void set_has_client();
  void clear_has_client();
  void set_has_threat_info();
  void clear_has_threat_info();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::mozilla::safebrowsing::ThreatInfo* threat_info_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindThreatMatchesResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FindThreatMatchesResponse) */ {
 public:
  FindThreatMatchesResponse();
  virtual ~FindThreatMatchesResponse();

  FindThreatMatchesResponse(const FindThreatMatchesResponse& from);

  inline FindThreatMatchesResponse& operator=(const FindThreatMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindThreatMatchesResponse(FindThreatMatchesResponse&& from) noexcept
    : FindThreatMatchesResponse() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesResponse& operator=(FindThreatMatchesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindThreatMatchesResponse& default_instance();

  static inline const FindThreatMatchesResponse* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesResponse*>(
               &_FindThreatMatchesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FindThreatMatchesResponse* other);
  friend void swap(FindThreatMatchesResponse& a, FindThreatMatchesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindThreatMatchesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FindThreatMatchesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FindThreatMatchesResponse& from);
  void MergeFrom(const FindThreatMatchesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  int matches_size() const;
  void clear_matches();
  static const int kMatchesFieldNumber = 1;
  const ::mozilla::safebrowsing::ThreatMatch& matches(int index) const;
  ::mozilla::safebrowsing::ThreatMatch* mutable_matches(int index);
  ::mozilla::safebrowsing::ThreatMatch* add_matches();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
      mutable_matches();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
      matches() const;

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindThreatMatchesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch > matches_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints) */ {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& default_instance();

  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other);
  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& a, FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  int supported_compressions_size() const;
  void clear_supported_compressions();
  static const int kSupportedCompressionsFieldNumber = 4;
  ::mozilla::safebrowsing::CompressionType supported_compressions(int index) const;
  void set_supported_compressions(int index, ::mozilla::safebrowsing::CompressionType value);
  void add_supported_compressions(::mozilla::safebrowsing::CompressionType value);
  const ::google::protobuf::RepeatedField<int>& supported_compressions() const;
  ::google::protobuf::RepeatedField<int>* mutable_supported_compressions();

  // optional string region = 3;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  const ::std::string& region() const;
  void set_region(const ::std::string& value);
  #if LANG_CXX11
  void set_region(::std::string&& value);
  #endif
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  ::std::string* mutable_region();
  ::std::string* release_region();
  void set_allocated_region(::std::string* region);

  // optional int32 max_update_entries = 1;
  bool has_max_update_entries() const;
  void clear_max_update_entries();
  static const int kMaxUpdateEntriesFieldNumber = 1;
  ::google::protobuf::int32 max_update_entries() const;
  void set_max_update_entries(::google::protobuf::int32 value);

  // optional int32 max_database_entries = 2;
  bool has_max_database_entries() const;
  void clear_max_database_entries();
  static const int kMaxDatabaseEntriesFieldNumber = 2;
  ::google::protobuf::int32 max_database_entries() const;
  void set_max_database_entries(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
 private:
  void set_has_max_update_entries();
  void clear_has_max_update_entries();
  void set_has_max_database_entries();
  void clear_has_max_database_entries();
  void set_has_region();
  void clear_has_region();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> supported_compressions_;
  ::google::protobuf::internal::ArenaStringPtr region_;
  ::google::protobuf::int32 max_update_entries_;
  ::google::protobuf::int32 max_database_entries_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest) */ {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest();

  FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);

  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchThreatListUpdatesRequest_ListUpdateRequest(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest& default_instance();

  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other);
  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest& a, FetchThreatListUpdatesRequest_ListUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest_ListUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchThreatListUpdatesRequest_ListUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints Constraints;

  // accessors -------------------------------------------------------

  // optional bytes state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const void* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  bool has_constraints() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 4;
  const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints() const;
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* mutable_constraints();
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* release_constraints();
  void set_allocated_constraints(::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints);

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_type() const;
  void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  ::mozilla::safebrowsing::PlatformType platform_type() const;
  void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 5;
  ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
 private:
  void set_has_threat_type();
  void clear_has_threat_type();
  void set_has_platform_type();
  void clear_has_platform_type();
  void set_has_threat_entry_type();
  void clear_has_threat_entry_type();
  void set_has_state();
  void clear_has_state();
  void set_has_constraints();
  void clear_has_constraints();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FetchThreatListUpdatesRequest) */ {
 public:
  FetchThreatListUpdatesRequest();
  virtual ~FetchThreatListUpdatesRequest();

  FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from);

  inline FetchThreatListUpdatesRequest& operator=(const FetchThreatListUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchThreatListUpdatesRequest(FetchThreatListUpdatesRequest&& from) noexcept
    : FetchThreatListUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest& operator=(FetchThreatListUpdatesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesRequest& default_instance();

  static inline const FetchThreatListUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest*>(
               &_FetchThreatListUpdatesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FetchThreatListUpdatesRequest* other);
  friend void swap(FetchThreatListUpdatesRequest& a, FetchThreatListUpdatesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchThreatListUpdatesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FetchThreatListUpdatesRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest ListUpdateRequest;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  int list_update_requests_size() const;
  void clear_list_update_requests();
  static const int kListUpdateRequestsFieldNumber = 3;
  const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest& list_update_requests(int index) const;
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* mutable_list_update_requests(int index);
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* add_list_update_requests();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
      mutable_list_update_requests();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
      list_update_requests() const;

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 1;
  const ::mozilla::safebrowsing::ClientInfo& client() const;
  ::mozilla::safebrowsing::ClientInfo* mutable_client();
  ::mozilla::safebrowsing::ClientInfo* release_client();
  void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
  bool has_chrome_client_info() const;
  void clear_chrome_client_info();
  static const int kChromeClientInfoFieldNumber = 4;
  const ::mozilla::safebrowsing::ChromeClientInfo& chrome_client_info() const;
  ::mozilla::safebrowsing::ChromeClientInfo* mutable_chrome_client_info();
  ::mozilla::safebrowsing::ChromeClientInfo* release_chrome_client_info();
  void set_allocated_chrome_client_info(::mozilla::safebrowsing::ChromeClientInfo* chrome_client_info);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
 private:
  void set_has_client();
  void clear_has_client();
  void set_has_chrome_client_info();
  void clear_has_chrome_client_info();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest > list_update_requests_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::mozilla::safebrowsing::ChromeClientInfo* chrome_client_info_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse_ListUpdateResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse) */ {
 public:
  FetchThreatListUpdatesResponse_ListUpdateResponse();
  virtual ~FetchThreatListUpdatesResponse_ListUpdateResponse();

  FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);

  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchThreatListUpdatesResponse_ListUpdateResponse(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept
    : FetchThreatListUpdatesResponse_ListUpdateResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesResponse_ListUpdateResponse& default_instance();

  static inline const FetchThreatListUpdatesResponse_ListUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
               &_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other);
  friend void swap(FetchThreatListUpdatesResponse_ListUpdateResponse& a, FetchThreatListUpdatesResponse_ListUpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesResponse_ListUpdateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchThreatListUpdatesResponse_ListUpdateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType ResponseType;
  static const ResponseType RESPONSE_TYPE_UNSPECIFIED =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
  static const ResponseType PARTIAL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE;
  static const ResponseType FULL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
  static inline bool ResponseType_IsValid(int value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  int additions_size() const;
  void clear_additions();
  static const int kAdditionsFieldNumber = 5;
  const ::mozilla::safebrowsing::ThreatEntrySet& additions(int index) const;
  ::mozilla::safebrowsing::ThreatEntrySet* mutable_additions(int index);
  ::mozilla::safebrowsing::ThreatEntrySet* add_additions();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
      mutable_additions();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
      additions() const;

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  int removals_size() const;
  void clear_removals();
  static const int kRemovalsFieldNumber = 6;
  const ::mozilla::safebrowsing::ThreatEntrySet& removals(int index) const;
  ::mozilla::safebrowsing::ThreatEntrySet* mutable_removals(int index);
  ::mozilla::safebrowsing::ThreatEntrySet* add_removals();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
      mutable_removals();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
      removals() const;

  // optional bytes new_client_state = 7;
  bool has_new_client_state() const;
  void clear_new_client_state();
  static const int kNewClientStateFieldNumber = 7;
  const ::std::string& new_client_state() const;
  void set_new_client_state(const ::std::string& value);
  #if LANG_CXX11
  void set_new_client_state(::std::string&& value);
  #endif
  void set_new_client_state(const char* value);
  void set_new_client_state(const void* value, size_t size);
  ::std::string* mutable_new_client_state();
  ::std::string* release_new_client_state();
  void set_allocated_new_client_state(::std::string* new_client_state);

  // optional .mozilla.safebrowsing.Checksum checksum = 8;
  bool has_checksum() const;
  void clear_checksum();
  static const int kChecksumFieldNumber = 8;
  const ::mozilla::safebrowsing::Checksum& checksum() const;
  ::mozilla::safebrowsing::Checksum* mutable_checksum();
  ::mozilla::safebrowsing::Checksum* release_checksum();
  void set_allocated_checksum(::mozilla::safebrowsing::Checksum* checksum);

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_type() const;
  void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 2;
  ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
  bool has_platform_type() const;
  void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 3;
  ::mozilla::safebrowsing::PlatformType platform_type() const;
  void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  bool has_response_type() const;
  void clear_response_type();
  static const int kResponseTypeFieldNumber = 4;
  ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType response_type() const;
  void set_response_type(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
 private:
  void set_has_threat_type();
  void clear_has_threat_type();
  void set_has_threat_entry_type();
  void clear_has_threat_entry_type();
  void set_has_platform_type();
  void clear_has_platform_type();
  void set_has_response_type();
  void clear_has_response_type();
  void set_has_new_client_state();
  void clear_has_new_client_state();
  void set_has_checksum();
  void clear_has_checksum();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet > additions_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet > removals_;
  ::google::protobuf::internal::ArenaStringPtr new_client_state_;
  ::mozilla::safebrowsing::Checksum* checksum_;
  int threat_type_;
  int threat_entry_type_;
  int platform_type_;
  int response_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FetchThreatListUpdatesResponse) */ {
 public:
  FetchThreatListUpdatesResponse();
  virtual ~FetchThreatListUpdatesResponse();

  FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from);

  inline FetchThreatListUpdatesResponse& operator=(const FetchThreatListUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchThreatListUpdatesResponse(FetchThreatListUpdatesResponse&& from) noexcept
    : FetchThreatListUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse& operator=(FetchThreatListUpdatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FetchThreatListUpdatesResponse& default_instance();

  static inline const FetchThreatListUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse*>(
               &_FetchThreatListUpdatesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(FetchThreatListUpdatesResponse* other);
  friend void swap(FetchThreatListUpdatesResponse& a, FetchThreatListUpdatesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchThreatListUpdatesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchThreatListUpdatesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FetchThreatListUpdatesResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse ListUpdateResponse;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  int list_update_responses_size() const;
  void clear_list_update_responses();
  static const int kListUpdateResponsesFieldNumber = 1;
  const ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse& list_update_responses(int index) const;
  ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* mutable_list_update_responses(int index);
  ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* add_list_update_responses();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
      mutable_list_update_responses();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
      list_update_responses() const;

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  void clear_minimum_wait_duration();
  static const int kMinimumWaitDurationFieldNumber = 2;
  const ::mozilla::safebrowsing::Duration& minimum_wait_duration() const;
  ::mozilla::safebrowsing::Duration* mutable_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* release_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
 private:
  void set_has_minimum_wait_duration();
  void clear_has_minimum_wait_duration();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse > list_update_responses_;
  ::mozilla::safebrowsing::Duration* minimum_wait_duration_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindFullHashesRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FindFullHashesRequest) */ {
 public:
  FindFullHashesRequest();
  virtual ~FindFullHashesRequest();

  FindFullHashesRequest(const FindFullHashesRequest& from);

  inline FindFullHashesRequest& operator=(const FindFullHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindFullHashesRequest(FindFullHashesRequest&& from) noexcept
    : FindFullHashesRequest() {
    *this = ::std::move(from);
  }

  inline FindFullHashesRequest& operator=(FindFullHashesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindFullHashesRequest& default_instance();

  static inline const FindFullHashesRequest* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesRequest*>(
               &_FindFullHashesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(FindFullHashesRequest* other);
  friend void swap(FindFullHashesRequest& a, FindFullHashesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindFullHashesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FindFullHashesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FindFullHashesRequest& from);
  void MergeFrom(const FindFullHashesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes client_states = 2;
  int client_states_size() const;
  void clear_client_states();
  static const int kClientStatesFieldNumber = 2;
  const ::std::string& client_states(int index) const;
  ::std::string* mutable_client_states(int index);
  void set_client_states(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_client_states(int index, ::std::string&& value);
  #endif
  void set_client_states(int index, const char* value);
  void set_client_states(int index, const void* value, size_t size);
  ::std::string* add_client_states();
  void add_client_states(const ::std::string& value);
  #if LANG_CXX11
  void add_client_states(::std::string&& value);
  #endif
  void add_client_states(const char* value);
  void add_client_states(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& client_states() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_client_states();

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 1;
  const ::mozilla::safebrowsing::ClientInfo& client() const;
  ::mozilla::safebrowsing::ClientInfo* mutable_client();
  ::mozilla::safebrowsing::ClientInfo* release_client();
  void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
  bool has_threat_info() const;
  void clear_threat_info();
  static const int kThreatInfoFieldNumber = 3;
  const ::mozilla::safebrowsing::ThreatInfo& threat_info() const;
  ::mozilla::safebrowsing::ThreatInfo* mutable_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* release_threat_info();
  void set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindFullHashesRequest)
 private:
  void set_has_client();
  void clear_has_client();
  void set_has_threat_info();
  void clear_has_threat_info();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> client_states_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::mozilla::safebrowsing::ThreatInfo* threat_info_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindFullHashesResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.FindFullHashesResponse) */ {
 public:
  FindFullHashesResponse();
  virtual ~FindFullHashesResponse();

  FindFullHashesResponse(const FindFullHashesResponse& from);

  inline FindFullHashesResponse& operator=(const FindFullHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindFullHashesResponse(FindFullHashesResponse&& from) noexcept
    : FindFullHashesResponse() {
    *this = ::std::move(from);
  }

  inline FindFullHashesResponse& operator=(FindFullHashesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FindFullHashesResponse& default_instance();

  static inline const FindFullHashesResponse* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesResponse*>(
               &_FindFullHashesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(FindFullHashesResponse* other);
  friend void swap(FindFullHashesResponse& a, FindFullHashesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindFullHashesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FindFullHashesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FindFullHashesResponse& from);
  void MergeFrom(const FindFullHashesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  int matches_size() const;
  void clear_matches();
  static const int kMatchesFieldNumber = 1;
  const ::mozilla::safebrowsing::ThreatMatch& matches(int index) const;
  ::mozilla::safebrowsing::ThreatMatch* mutable_matches(int index);
  ::mozilla::safebrowsing::ThreatMatch* add_matches();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
      mutable_matches();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
      matches() const;

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  void clear_minimum_wait_duration();
  static const int kMinimumWaitDurationFieldNumber = 2;
  const ::mozilla::safebrowsing::Duration& minimum_wait_duration() const;
  ::mozilla::safebrowsing::Duration* mutable_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* release_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration);

  // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
  bool has_negative_cache_duration() const;
  void clear_negative_cache_duration();
  static const int kNegativeCacheDurationFieldNumber = 3;
  const ::mozilla::safebrowsing::Duration& negative_cache_duration() const;
  ::mozilla::safebrowsing::Duration* mutable_negative_cache_duration();
  ::mozilla::safebrowsing::Duration* release_negative_cache_duration();
  void set_allocated_negative_cache_duration(::mozilla::safebrowsing::Duration* negative_cache_duration);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindFullHashesResponse)
 private:
  void set_has_minimum_wait_duration();
  void clear_has_minimum_wait_duration();
  void set_has_negative_cache_duration();
  void clear_has_negative_cache_duration();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch > matches_;
  ::mozilla::safebrowsing::Duration* minimum_wait_duration_;
  ::mozilla::safebrowsing::Duration* negative_cache_duration_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatHit_ThreatSource : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatHit.ThreatSource) */ {
 public:
  ThreatHit_ThreatSource();
  virtual ~ThreatHit_ThreatSource();

  ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from);

  inline ThreatHit_ThreatSource& operator=(const ThreatHit_ThreatSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatHit_ThreatSource(ThreatHit_ThreatSource&& from) noexcept
    : ThreatHit_ThreatSource() {
    *this = ::std::move(from);
  }

  inline ThreatHit_ThreatSource& operator=(ThreatHit_ThreatSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatHit_ThreatSource& default_instance();

  static inline const ThreatHit_ThreatSource* internal_default_instance() {
    return reinterpret_cast<const ThreatHit_ThreatSource*>(
               &_ThreatHit_ThreatSource_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ThreatHit_ThreatSource* other);
  friend void swap(ThreatHit_ThreatSource& a, ThreatHit_ThreatSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatHit_ThreatSource* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatHit_ThreatSource* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatHit_ThreatSource& from);
  void MergeFrom(const ThreatHit_ThreatSource& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit_ThreatSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string remote_ip = 3;
  bool has_remote_ip() const;
  void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 3;
  const ::std::string& remote_ip() const;
  void set_remote_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_ip(::std::string&& value);
  #endif
  void set_remote_ip(const char* value);
  void set_remote_ip(const char* value, size_t size);
  ::std::string* mutable_remote_ip();
  ::std::string* release_remote_ip();
  void set_allocated_remote_ip(::std::string* remote_ip);

  // optional string referrer = 4;
  bool has_referrer() const;
  void clear_referrer();
  static const int kReferrerFieldNumber = 4;
  const ::std::string& referrer() const;
  void set_referrer(const ::std::string& value);
  #if LANG_CXX11
  void set_referrer(::std::string&& value);
  #endif
  void set_referrer(const char* value);
  void set_referrer(const char* value, size_t size);
  ::std::string* mutable_referrer();
  ::std::string* release_referrer();
  void set_allocated_referrer(::std::string* referrer);

  // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mozilla::safebrowsing::ThreatHit_ThreatSourceType type() const;
  void set_type(::mozilla::safebrowsing::ThreatHit_ThreatSourceType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatHit.ThreatSource)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_type();
  void clear_has_type();
  void set_has_remote_ip();
  void clear_has_remote_ip();
  void set_has_referrer();
  void clear_has_referrer();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr remote_ip_;
  ::google::protobuf::internal::ArenaStringPtr referrer_;
  int type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatHit_UserInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatHit.UserInfo) */ {
 public:
  ThreatHit_UserInfo();
  virtual ~ThreatHit_UserInfo();

  ThreatHit_UserInfo(const ThreatHit_UserInfo& from);

  inline ThreatHit_UserInfo& operator=(const ThreatHit_UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatHit_UserInfo(ThreatHit_UserInfo&& from) noexcept
    : ThreatHit_UserInfo() {
    *this = ::std::move(from);
  }

  inline ThreatHit_UserInfo& operator=(ThreatHit_UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatHit_UserInfo& default_instance();

  static inline const ThreatHit_UserInfo* internal_default_instance() {
    return reinterpret_cast<const ThreatHit_UserInfo*>(
               &_ThreatHit_UserInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ThreatHit_UserInfo* other);
  friend void swap(ThreatHit_UserInfo& a, ThreatHit_UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatHit_UserInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatHit_UserInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatHit_UserInfo& from);
  void MergeFrom(const ThreatHit_UserInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit_UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string region_code = 1;
  bool has_region_code() const;
  void clear_region_code();
  static const int kRegionCodeFieldNumber = 1;
  const ::std::string& region_code() const;
  void set_region_code(const ::std::string& value);
  #if LANG_CXX11
  void set_region_code(::std::string&& value);
  #endif
  void set_region_code(const char* value);
  void set_region_code(const char* value, size_t size);
  ::std::string* mutable_region_code();
  ::std::string* release_region_code();
  void set_allocated_region_code(::std::string* region_code);

  // optional bytes user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatHit.UserInfo)
 private:
  void set_has_region_code();
  void clear_has_region_code();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr region_code_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatHit : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatHit) */ {
 public:
  ThreatHit();
  virtual ~ThreatHit();

  ThreatHit(const ThreatHit& from);

  inline ThreatHit& operator=(const ThreatHit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatHit(ThreatHit&& from) noexcept
    : ThreatHit() {
    *this = ::std::move(from);
  }

  inline ThreatHit& operator=(ThreatHit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatHit& default_instance();

  static inline const ThreatHit* internal_default_instance() {
    return reinterpret_cast<const ThreatHit*>(
               &_ThreatHit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ThreatHit* other);
  friend void swap(ThreatHit& a, ThreatHit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatHit* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatHit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatHit& from);
  void MergeFrom(const ThreatHit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ThreatHit_ThreatSource ThreatSource;
  typedef ThreatHit_UserInfo UserInfo;

  typedef ThreatHit_ThreatSourceType ThreatSourceType;
  static const ThreatSourceType THREAT_SOURCE_TYPE_UNSPECIFIED =
    ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
  static const ThreatSourceType MATCHING_URL =
    ThreatHit_ThreatSourceType_MATCHING_URL;
  static const ThreatSourceType TAB_URL =
    ThreatHit_ThreatSourceType_TAB_URL;
  static const ThreatSourceType TAB_REDIRECT =
    ThreatHit_ThreatSourceType_TAB_REDIRECT;
  static const ThreatSourceType TAB_RESOURCE =
    ThreatHit_ThreatSourceType_TAB_RESOURCE;
  static inline bool ThreatSourceType_IsValid(int value) {
    return ThreatHit_ThreatSourceType_IsValid(value);
  }
  static const ThreatSourceType ThreatSourceType_MIN =
    ThreatHit_ThreatSourceType_ThreatSourceType_MIN;
  static const ThreatSourceType ThreatSourceType_MAX =
    ThreatHit_ThreatSourceType_ThreatSourceType_MAX;
  static const int ThreatSourceType_ARRAYSIZE =
    ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 4;
  const ::mozilla::safebrowsing::ThreatHit_ThreatSource& resources(int index) const;
  ::mozilla::safebrowsing::ThreatHit_ThreatSource* mutable_resources(int index);
  ::mozilla::safebrowsing::ThreatHit_ThreatSource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >&
      resources() const;

  // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
  bool has_entry() const;
  void clear_entry();
  static const int kEntryFieldNumber = 3;
  const ::mozilla::safebrowsing::ThreatEntry& entry() const;
  ::mozilla::safebrowsing::ThreatEntry* mutable_entry();
  ::mozilla::safebrowsing::ThreatEntry* release_entry();
  void set_allocated_entry(::mozilla::safebrowsing::ThreatEntry* entry);

  // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 5;
  const ::mozilla::safebrowsing::ClientInfo& client_info() const;
  ::mozilla::safebrowsing::ClientInfo* mutable_client_info();
  ::mozilla::safebrowsing::ClientInfo* release_client_info();
  void set_allocated_client_info(::mozilla::safebrowsing::ClientInfo* client_info);

  // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 6;
  const ::mozilla::safebrowsing::ThreatHit_UserInfo& user_info() const;
  ::mozilla::safebrowsing::ThreatHit_UserInfo* mutable_user_info();
  ::mozilla::safebrowsing::ThreatHit_UserInfo* release_user_info();
  void set_allocated_user_info(::mozilla::safebrowsing::ThreatHit_UserInfo* user_info);

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_type() const;
  void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  ::mozilla::safebrowsing::PlatformType platform_type() const;
  void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatHit)
 private:
  void set_has_threat_type();
  void clear_has_threat_type();
  void set_has_platform_type();
  void clear_has_platform_type();
  void set_has_entry();
  void clear_has_entry();
  void set_has_client_info();
  void clear_has_client_info();
  void set_has_user_info();
  void clear_has_user_info();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource > resources_;
  ::mozilla::safebrowsing::ThreatEntry* entry_;
  ::mozilla::safebrowsing::ClientInfo* client_info_;
  ::mozilla::safebrowsing::ThreatHit_UserInfo* user_info_;
  int threat_type_;
  int platform_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ClientInfo) */ {
 public:
  ClientInfo();
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientInfo& default_instance();

  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ClientInfo* other);
  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // optional string client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  const ::std::string& client_version() const;
  void set_client_version(const ::std::string& value);
  #if LANG_CXX11
  void set_client_version(::std::string&& value);
  #endif
  void set_client_version(const char* value);
  void set_client_version(const char* value, size_t size);
  ::std::string* mutable_client_version();
  ::std::string* release_client_version();
  void set_allocated_client_version(::std::string* client_version);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ClientInfo)
 private:
  void set_has_client_id();
  void clear_has_client_id();
  void set_has_client_version();
  void clear_has_client_version();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::internal::ArenaStringPtr client_version_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChromeClientInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ChromeClientInfo) */ {
 public:
  ChromeClientInfo();
  virtual ~ChromeClientInfo();

  ChromeClientInfo(const ChromeClientInfo& from);

  inline ChromeClientInfo& operator=(const ChromeClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChromeClientInfo(ChromeClientInfo&& from) noexcept
    : ChromeClientInfo() {
    *this = ::std::move(from);
  }

  inline ChromeClientInfo& operator=(ChromeClientInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChromeClientInfo& default_instance();

  static inline const ChromeClientInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeClientInfo*>(
               &_ChromeClientInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ChromeClientInfo* other);
  friend void swap(ChromeClientInfo& a, ChromeClientInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChromeClientInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ChromeClientInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ChromeClientInfo& from);
  void MergeFrom(const ChromeClientInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeClientInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChromeClientInfo_SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation;
  static const SafeBrowsingReportingPopulation UNSPECIFIED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
  static const SafeBrowsingReportingPopulation OPT_OUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT;
  static const SafeBrowsingReportingPopulation EXTENDED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED;
  static const SafeBrowsingReportingPopulation SCOUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
  static inline bool SafeBrowsingReportingPopulation_IsValid(int value) {
    return ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value);
  }
  static const SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MIN =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN;
  static const SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MAX =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX;
  static const int SafeBrowsingReportingPopulation_ARRAYSIZE =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  bool has_reporting_population() const;
  void clear_reporting_population();
  static const int kReportingPopulationFieldNumber = 1;
  ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation reporting_population() const;
  void set_reporting_population(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ChromeClientInfo)
 private:
  void set_has_reporting_population();
  void clear_has_reporting_population();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int reporting_population_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Checksum : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.Checksum) */ {
 public:
  Checksum();
  virtual ~Checksum();

  Checksum(const Checksum& from);

  inline Checksum& operator=(const Checksum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Checksum(Checksum&& from) noexcept
    : Checksum() {
    *this = ::std::move(from);
  }

  inline Checksum& operator=(Checksum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Checksum& default_instance();

  static inline const Checksum* internal_default_instance() {
    return reinterpret_cast<const Checksum*>(
               &_Checksum_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Checksum* other);
  friend void swap(Checksum& a, Checksum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Checksum* New() const PROTOBUF_FINAL { return New(NULL); }

  Checksum* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Checksum& from);
  void MergeFrom(const Checksum& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Checksum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha256 = 1;
  bool has_sha256() const;
  void clear_sha256();
  static const int kSha256FieldNumber = 1;
  const ::std::string& sha256() const;
  void set_sha256(const ::std::string& value);
  #if LANG_CXX11
  void set_sha256(::std::string&& value);
  #endif
  void set_sha256(const char* value);
  void set_sha256(const void* value, size_t size);
  ::std::string* mutable_sha256();
  ::std::string* release_sha256();
  void set_allocated_sha256(::std::string* sha256);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.Checksum)
 private:
  void set_has_sha256();
  void clear_has_sha256();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sha256_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatEntry : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatEntry) */ {
 public:
  ThreatEntry();
  virtual ~ThreatEntry();

  ThreatEntry(const ThreatEntry& from);

  inline ThreatEntry& operator=(const ThreatEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatEntry(ThreatEntry&& from) noexcept
    : ThreatEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntry& operator=(ThreatEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntry& default_instance();

  static inline const ThreatEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntry*>(
               &_ThreatEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ThreatEntry* other);
  friend void swap(ThreatEntry& a, ThreatEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatEntry& from);
  void MergeFrom(const ThreatEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntry)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatEntrySet : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatEntrySet) */ {
 public:
  ThreatEntrySet();
  virtual ~ThreatEntrySet();

  ThreatEntrySet(const ThreatEntrySet& from);

  inline ThreatEntrySet& operator=(const ThreatEntrySet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatEntrySet(ThreatEntrySet&& from) noexcept
    : ThreatEntrySet() {
    *this = ::std::move(from);
  }

  inline ThreatEntrySet& operator=(ThreatEntrySet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntrySet& default_instance();

  static inline const ThreatEntrySet* internal_default_instance() {
    return reinterpret_cast<const ThreatEntrySet*>(
               &_ThreatEntrySet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ThreatEntrySet* other);
  friend void swap(ThreatEntrySet& a, ThreatEntrySet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntrySet* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatEntrySet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatEntrySet& from);
  void MergeFrom(const ThreatEntrySet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntrySet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
  bool has_raw_hashes() const;
  void clear_raw_hashes();
  static const int kRawHashesFieldNumber = 2;
  const ::mozilla::safebrowsing::RawHashes& raw_hashes() const;
  ::mozilla::safebrowsing::RawHashes* mutable_raw_hashes();
  ::mozilla::safebrowsing::RawHashes* release_raw_hashes();
  void set_allocated_raw_hashes(::mozilla::safebrowsing::RawHashes* raw_hashes);

  // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
  bool has_raw_indices() const;
  void clear_raw_indices();
  static const int kRawIndicesFieldNumber = 3;
  const ::mozilla::safebrowsing::RawIndices& raw_indices() const;
  ::mozilla::safebrowsing::RawIndices* mutable_raw_indices();
  ::mozilla::safebrowsing::RawIndices* release_raw_indices();
  void set_allocated_raw_indices(::mozilla::safebrowsing::RawIndices* raw_indices);

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
  bool has_rice_hashes() const;
  void clear_rice_hashes();
  static const int kRiceHashesFieldNumber = 4;
  const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_hashes() const;
  ::mozilla::safebrowsing::RiceDeltaEncoding* mutable_rice_hashes();
  ::mozilla::safebrowsing::RiceDeltaEncoding* release_rice_hashes();
  void set_allocated_rice_hashes(::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes);

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
  bool has_rice_indices() const;
  void clear_rice_indices();
  static const int kRiceIndicesFieldNumber = 5;
  const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_indices() const;
  ::mozilla::safebrowsing::RiceDeltaEncoding* mutable_rice_indices();
  ::mozilla::safebrowsing::RiceDeltaEncoding* release_rice_indices();
  void set_allocated_rice_indices(::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices);

  // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
  bool has_compression_type() const;
  void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 1;
  ::mozilla::safebrowsing::CompressionType compression_type() const;
  void set_compression_type(::mozilla::safebrowsing::CompressionType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntrySet)
 private:
  void set_has_compression_type();
  void clear_has_compression_type();
  void set_has_raw_hashes();
  void clear_has_raw_hashes();
  void set_has_raw_indices();
  void clear_has_raw_indices();
  void set_has_rice_hashes();
  void clear_has_rice_hashes();
  void set_has_rice_indices();
  void clear_has_rice_indices();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mozilla::safebrowsing::RawHashes* raw_hashes_;
  ::mozilla::safebrowsing::RawIndices* raw_indices_;
  ::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes_;
  ::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices_;
  int compression_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawIndices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.RawIndices) */ {
 public:
  RawIndices();
  virtual ~RawIndices();

  RawIndices(const RawIndices& from);

  inline RawIndices& operator=(const RawIndices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawIndices(RawIndices&& from) noexcept
    : RawIndices() {
    *this = ::std::move(from);
  }

  inline RawIndices& operator=(RawIndices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RawIndices& default_instance();

  static inline const RawIndices* internal_default_instance() {
    return reinterpret_cast<const RawIndices*>(
               &_RawIndices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RawIndices* other);
  friend void swap(RawIndices& a, RawIndices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawIndices* New() const PROTOBUF_FINAL { return New(NULL); }

  RawIndices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RawIndices& from);
  void MergeFrom(const RawIndices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawIndices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 indices = 1;
  int indices_size() const;
  void clear_indices();
  static const int kIndicesFieldNumber = 1;
  ::google::protobuf::int32 indices(int index) const;
  void set_indices(int index, ::google::protobuf::int32 value);
  void add_indices(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      indices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RawIndices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > indices_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawHashes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.RawHashes) */ {
 public:
  RawHashes();
  virtual ~RawHashes();

  RawHashes(const RawHashes& from);

  inline RawHashes& operator=(const RawHashes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawHashes(RawHashes&& from) noexcept
    : RawHashes() {
    *this = ::std::move(from);
  }

  inline RawHashes& operator=(RawHashes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RawHashes& default_instance();

  static inline const RawHashes* internal_default_instance() {
    return reinterpret_cast<const RawHashes*>(
               &_RawHashes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RawHashes* other);
  friend void swap(RawHashes& a, RawHashes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawHashes* New() const PROTOBUF_FINAL { return New(NULL); }

  RawHashes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RawHashes& from);
  void MergeFrom(const RawHashes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawHashes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes raw_hashes = 2;
  bool has_raw_hashes() const;
  void clear_raw_hashes();
  static const int kRawHashesFieldNumber = 2;
  const ::std::string& raw_hashes() const;
  void set_raw_hashes(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_hashes(::std::string&& value);
  #endif
  void set_raw_hashes(const char* value);
  void set_raw_hashes(const void* value, size_t size);
  ::std::string* mutable_raw_hashes();
  ::std::string* release_raw_hashes();
  void set_allocated_raw_hashes(::std::string* raw_hashes);

  // optional int32 prefix_size = 1;
  bool has_prefix_size() const;
  void clear_prefix_size();
  static const int kPrefixSizeFieldNumber = 1;
  ::google::protobuf::int32 prefix_size() const;
  void set_prefix_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RawHashes)
 private:
  void set_has_prefix_size();
  void clear_has_prefix_size();
  void set_has_raw_hashes();
  void clear_has_raw_hashes();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr raw_hashes_;
  ::google::protobuf::int32 prefix_size_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RiceDeltaEncoding : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.RiceDeltaEncoding) */ {
 public:
  RiceDeltaEncoding();
  virtual ~RiceDeltaEncoding();

  RiceDeltaEncoding(const RiceDeltaEncoding& from);

  inline RiceDeltaEncoding& operator=(const RiceDeltaEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RiceDeltaEncoding(RiceDeltaEncoding&& from) noexcept
    : RiceDeltaEncoding() {
    *this = ::std::move(from);
  }

  inline RiceDeltaEncoding& operator=(RiceDeltaEncoding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RiceDeltaEncoding& default_instance();

  static inline const RiceDeltaEncoding* internal_default_instance() {
    return reinterpret_cast<const RiceDeltaEncoding*>(
               &_RiceDeltaEncoding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RiceDeltaEncoding* other);
  friend void swap(RiceDeltaEncoding& a, RiceDeltaEncoding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RiceDeltaEncoding* New() const PROTOBUF_FINAL { return New(NULL); }

  RiceDeltaEncoding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RiceDeltaEncoding& from);
  void MergeFrom(const RiceDeltaEncoding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RiceDeltaEncoding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encoded_data = 4;
  bool has_encoded_data() const;
  void clear_encoded_data();
  static const int kEncodedDataFieldNumber = 4;
  const ::std::string& encoded_data() const;
  void set_encoded_data(const ::std::string& value);
  #if LANG_CXX11
  void set_encoded_data(::std::string&& value);
  #endif
  void set_encoded_data(const char* value);
  void set_encoded_data(const void* value, size_t size);
  ::std::string* mutable_encoded_data();
  ::std::string* release_encoded_data();
  void set_allocated_encoded_data(::std::string* encoded_data);

  // optional int64 first_value = 1;
  bool has_first_value() const;
  void clear_first_value();
  static const int kFirstValueFieldNumber = 1;
  ::google::protobuf::int64 first_value() const;
  void set_first_value(::google::protobuf::int64 value);

  // optional int32 rice_parameter = 2;
  bool has_rice_parameter() const;
  void clear_rice_parameter();
  static const int kRiceParameterFieldNumber = 2;
  ::google::protobuf::int32 rice_parameter() const;
  void set_rice_parameter(::google::protobuf::int32 value);

  // optional int32 num_entries = 3;
  bool has_num_entries() const;
  void clear_num_entries();
  static const int kNumEntriesFieldNumber = 3;
  ::google::protobuf::int32 num_entries() const;
  void set_num_entries(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RiceDeltaEncoding)
 private:
  void set_has_first_value();
  void clear_has_first_value();
  void set_has_rice_parameter();
  void clear_has_rice_parameter();
  void set_has_num_entries();
  void clear_has_num_entries();
  void set_has_encoded_data();
  void clear_has_encoded_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr encoded_data_;
  ::google::protobuf::int64 first_value_;
  ::google::protobuf::int32 rice_parameter_;
  ::google::protobuf::int32 num_entries_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata_MetadataEntry : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry) */ {
 public:
  ThreatEntryMetadata_MetadataEntry();
  virtual ~ThreatEntryMetadata_MetadataEntry();

  ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from);

  inline ThreatEntryMetadata_MetadataEntry& operator=(const ThreatEntryMetadata_MetadataEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatEntryMetadata_MetadataEntry(ThreatEntryMetadata_MetadataEntry&& from) noexcept
    : ThreatEntryMetadata_MetadataEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata_MetadataEntry& operator=(ThreatEntryMetadata_MetadataEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntryMetadata_MetadataEntry& default_instance();

  static inline const ThreatEntryMetadata_MetadataEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata_MetadataEntry*>(
               &_ThreatEntryMetadata_MetadataEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ThreatEntryMetadata_MetadataEntry* other);
  friend void swap(ThreatEntryMetadata_MetadataEntry& a, ThreatEntryMetadata_MetadataEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntryMetadata_MetadataEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatEntryMetadata_MetadataEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void MergeFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata_MetadataEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatEntryMetadata) */ {
 public:
  ThreatEntryMetadata();
  virtual ~ThreatEntryMetadata();

  ThreatEntryMetadata(const ThreatEntryMetadata& from);

  inline ThreatEntryMetadata& operator=(const ThreatEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatEntryMetadata(ThreatEntryMetadata&& from) noexcept
    : ThreatEntryMetadata() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata& operator=(ThreatEntryMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatEntryMetadata& default_instance();

  static inline const ThreatEntryMetadata* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata*>(
               &_ThreatEntryMetadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ThreatEntryMetadata* other);
  friend void swap(ThreatEntryMetadata& a, ThreatEntryMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatEntryMetadata* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatEntryMetadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatEntryMetadata& from);
  void MergeFrom(const ThreatEntryMetadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ThreatEntryMetadata_MetadataEntry MetadataEntry;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  const ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry& entries(int index) const;
  ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* mutable_entries(int index);
  ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* add_entries();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntryMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry > entries_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThreatListDescriptor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ThreatListDescriptor) */ {
 public:
  ThreatListDescriptor();
  virtual ~ThreatListDescriptor();

  ThreatListDescriptor(const ThreatListDescriptor& from);

  inline ThreatListDescriptor& operator=(const ThreatListDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThreatListDescriptor(ThreatListDescriptor&& from) noexcept
    : ThreatListDescriptor() {
    *this = ::std::move(from);
  }

  inline ThreatListDescriptor& operator=(ThreatListDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ThreatListDescriptor& default_instance();

  static inline const ThreatListDescriptor* internal_default_instance() {
    return reinterpret_cast<const ThreatListDescriptor*>(
               &_ThreatListDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(ThreatListDescriptor* other);
  friend void swap(ThreatListDescriptor& a, ThreatListDescriptor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThreatListDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  ThreatListDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ThreatListDescriptor& from);
  void MergeFrom(const ThreatListDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatListDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  ::mozilla::safebrowsing::ThreatType threat_type() const;
  void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  ::mozilla::safebrowsing::PlatformType platform_type() const;
  void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
  bool has_threat_entry_type() const;
  void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 3;
  ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatListDescriptor)
 private:
  void set_has_threat_type();
  void clear_has_threat_type();
  void set_has_platform_type();
  void clear_has_platform_type();
  void set_has_threat_entry_type();
  void clear_has_threat_entry_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListThreatListsResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.ListThreatListsResponse) */ {
 public:
  ListThreatListsResponse();
  virtual ~ListThreatListsResponse();

  ListThreatListsResponse(const ListThreatListsResponse& from);

  inline ListThreatListsResponse& operator=(const ListThreatListsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListThreatListsResponse(ListThreatListsResponse&& from) noexcept
    : ListThreatListsResponse() {
    *this = ::std::move(from);
  }

  inline ListThreatListsResponse& operator=(ListThreatListsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ListThreatListsResponse& default_instance();

  static inline const ListThreatListsResponse* internal_default_instance() {
    return reinterpret_cast<const ListThreatListsResponse*>(
               &_ListThreatListsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ListThreatListsResponse* other);
  friend void swap(ListThreatListsResponse& a, ListThreatListsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListThreatListsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ListThreatListsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ListThreatListsResponse& from);
  void MergeFrom(const ListThreatListsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListThreatListsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  int threat_lists_size() const;
  void clear_threat_lists();
  static const int kThreatListsFieldNumber = 1;
  const ::mozilla::safebrowsing::ThreatListDescriptor& threat_lists(int index) const;
  ::mozilla::safebrowsing::ThreatListDescriptor* mutable_threat_lists(int index);
  ::mozilla::safebrowsing::ThreatListDescriptor* add_threat_lists();
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >*
      mutable_threat_lists();
  const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >&
      threat_lists() const;

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ListThreatListsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor > threat_lists_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Duration : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mozilla.safebrowsing.Duration) */ {
 public:
  Duration();
  virtual ~Duration();

  Duration(const Duration& from);

  inline Duration& operator=(const Duration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Duration(Duration&& from) noexcept
    : Duration() {
    *this = ::std::move(from);
  }

  inline Duration& operator=(Duration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Duration& default_instance();

  static inline const Duration* internal_default_instance() {
    return reinterpret_cast<const Duration*>(
               &_Duration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Duration* other);
  friend void swap(Duration& a, Duration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Duration* New() const PROTOBUF_FINAL { return New(NULL); }

  Duration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Duration& from);
  void MergeFrom(const Duration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Duration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // optional int32 nanos = 2;
  bool has_nanos() const;
  void clear_nanos();
  static const int kNanosFieldNumber = 2;
  ::google::protobuf::int32 nanos() const;
  void set_nanos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.Duration)
 private:
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_nanos();
  void clear_has_nanos();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int32 nanos_;
  friend struct protobuf_safebrowsing_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ThreatInfo

// repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
inline int ThreatInfo::threat_types_size() const {
  return threat_types_.size();
}
inline void ThreatInfo::clear_threat_types() {
  threat_types_.Clear();
}
inline ::mozilla::safebrowsing::ThreatType ThreatInfo::threat_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_types)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_types_.Get(index));
}
inline void ThreatInfo::set_threat_types(int index, ::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_types)
}
inline void ThreatInfo::add_threat_types(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return threat_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return &threat_types_;
}

// repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
inline int ThreatInfo::platform_types_size() const {
  return platform_types_.size();
}
inline void ThreatInfo::clear_platform_types() {
  platform_types_.Clear();
}
inline ::mozilla::safebrowsing::PlatformType ThreatInfo::platform_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.platform_types)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_types_.Get(index));
}
inline void ThreatInfo::set_platform_types(int index, ::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.platform_types)
}
inline void ThreatInfo::add_platform_types(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.platform_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::platform_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return platform_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_platform_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return &platform_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
inline int ThreatInfo::threat_entry_types_size() const {
  return threat_entry_types_.size();
}
inline void ThreatInfo::clear_threat_entry_types() {
  threat_entry_types_.Clear();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_types_.Get(index));
}
inline void ThreatInfo::set_threat_entry_types(int index, ::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
inline void ThreatInfo::add_threat_entry_types(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_entry_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return threat_entry_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return &threat_entry_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
inline int ThreatInfo::threat_entries_size() const {
  return threat_entries_.size();
}
inline void ThreatInfo::clear_threat_entries() {
  threat_entries_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatInfo::threat_entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatInfo::add_threat_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >*
ThreatInfo::mutable_threat_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return &threat_entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >&
ThreatInfo::threat_entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_;
}

// -------------------------------------------------------------------

// ThreatMatch

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatMatch::has_threat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatMatch::set_has_threat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatMatch::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatMatch::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatMatch::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatMatch::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatMatch::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatMatch::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThreatMatch::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThreatMatch::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatMatch::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatMatch::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
inline bool ThreatMatch::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ThreatMatch::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ThreatMatch::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ThreatMatch::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatMatch::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatMatch::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
}

// optional .mozilla.safebrowsing.ThreatEntry threat = 3;
inline bool ThreatMatch::has_threat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatMatch::set_has_threat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatMatch::clear_has_threat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatMatch::clear_threat() {
  if (threat_ != NULL) threat_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_threat();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatMatch::threat() const {
  const ::mozilla::safebrowsing::ThreatEntry* p = threat_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntry*>(
      &::mozilla::safebrowsing::_ThreatEntry_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatMatch::mutable_threat() {
  set_has_threat();
  if (threat_ == NULL) {
    threat_ = new ::mozilla::safebrowsing::ThreatEntry;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat)
  return threat_;
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatMatch::release_threat() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.threat)
  clear_has_threat();
  ::mozilla::safebrowsing::ThreatEntry* temp = threat_;
  threat_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_threat(::mozilla::safebrowsing::ThreatEntry* threat) {
  delete threat_;
  threat_ = threat;
  if (threat) {
    set_has_threat();
  } else {
    clear_has_threat();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat)
}

// optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
inline bool ThreatMatch::has_threat_entry_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatMatch::set_has_threat_entry_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatMatch::clear_has_threat_entry_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatMatch::clear_threat_entry_metadata() {
  if (threat_entry_metadata_ != NULL) threat_entry_metadata_->::mozilla::safebrowsing::ThreatEntryMetadata::Clear();
  clear_has_threat_entry_metadata();
}
inline const ::mozilla::safebrowsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const {
  const ::mozilla::safebrowsing::ThreatEntryMetadata* p = threat_entry_metadata_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntryMetadata*>(
      &::mozilla::safebrowsing::_ThreatEntryMetadata_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata() {
  set_has_threat_entry_metadata();
  if (threat_entry_metadata_ == NULL) {
    threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  return threat_entry_metadata_;
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  clear_has_threat_entry_metadata();
  ::mozilla::safebrowsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_threat_entry_metadata(::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata) {
  delete threat_entry_metadata_;
  threat_entry_metadata_ = threat_entry_metadata;
  if (threat_entry_metadata) {
    set_has_threat_entry_metadata();
  } else {
    clear_has_threat_entry_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
}

// optional .mozilla.safebrowsing.Duration cache_duration = 5;
inline bool ThreatMatch::has_cache_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatMatch::set_has_cache_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatMatch::clear_has_cache_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatMatch::clear_cache_duration() {
  if (cache_duration_ != NULL) cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_cache_duration();
}
inline const ::mozilla::safebrowsing::Duration& ThreatMatch::cache_duration() const {
  const ::mozilla::safebrowsing::Duration* p = cache_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.cache_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
inline ::mozilla::safebrowsing::Duration* ThreatMatch::mutable_cache_duration() {
  set_has_cache_duration();
  if (cache_duration_ == NULL) {
    cache_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.cache_duration)
  return cache_duration_;
}
inline ::mozilla::safebrowsing::Duration* ThreatMatch::release_cache_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.cache_duration)
  clear_has_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = cache_duration_;
  cache_duration_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_cache_duration(::mozilla::safebrowsing::Duration* cache_duration) {
  delete cache_duration_;
  cache_duration_ = cache_duration;
  if (cache_duration) {
    set_has_cache_duration();
  } else {
    clear_has_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.cache_duration)
}

// -------------------------------------------------------------------

// FindThreatMatchesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FindThreatMatchesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindThreatMatchesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindThreatMatchesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindThreatMatchesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FindThreatMatchesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FindThreatMatchesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.client)
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
inline bool FindThreatMatchesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindThreatMatchesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindThreatMatchesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindThreatMatchesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
inline const ::mozilla::safebrowsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const {
  const ::mozilla::safebrowsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatInfo*>(
      &::mozilla::safebrowsing::_ThreatInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  return threat_info_;
}
inline ::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
inline void FindThreatMatchesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindThreatMatchesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
inline int FindThreatMatchesResponse::matches_size() const {
  return matches_.size();
}
inline void FindThreatMatchesResponse::clear_matches() {
  matches_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindThreatMatchesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return &matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindThreatMatchesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_update_entries() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_update_entries() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries() {
  max_update_entries_ = 0;
  clear_has_max_update_entries();
}
inline ::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
  return max_update_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(::google::protobuf::int32 value) {
  set_has_max_update_entries();
  max_update_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_database_entries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_database_entries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries() {
  max_database_entries_ = 0;
  clear_has_max_database_entries();
}
inline ::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
  return max_database_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(::google::protobuf::int32 value) {
  set_has_max_database_entries();
  max_database_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region() {
  region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_region();
}
inline const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.GetNoArena();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const ::std::string& value) {
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
#if LANG_CXX11
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(::std::string&& value) {
  set_has_region();
  region_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
#endif
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value, size_t size) {
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region() {
  set_has_region();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  clear_has_region();
  return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(::std::string* region) {
  if (region != NULL) {
    set_has_region();
  } else {
    clear_has_region();
  }
  region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
inline int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const {
  return supported_compressions_.size();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions() {
  supported_compressions_.Clear();
}
inline ::mozilla::safebrowsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(supported_compressions_.Get(index));
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline const ::google::protobuf::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return supported_compressions_;
}
inline ::google::protobuf::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return &supported_compressions_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_platform_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.GetNoArena();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
#if LANG_CXX11
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(::std::string&& value) {
  set_has_state();
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
#endif
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const void* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_constraints() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_constraints() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints() {
  if (constraints_ != NULL) constraints_->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
  clear_has_constraints();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const {
  const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* p = constraints_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints() {
  set_has_constraints();
  if (constraints_ == NULL) {
    constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return constraints_;
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  clear_has_constraints();
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  delete constraints_;
  constraints_ = constraints;
  if (constraints) {
    set_has_constraints();
  } else {
    clear_has_constraints();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FetchThreatListUpdatesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FetchThreatListUpdatesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
}

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
inline int FetchThreatListUpdatesRequest::list_update_requests_size() const {
  return list_update_requests_.size();
}
inline void FetchThreatListUpdatesRequest::clear_list_update_requests() {
  list_update_requests_.Clear();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Get(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Mutable(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
FetchThreatListUpdatesRequest::mutable_list_update_requests() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return &list_update_requests_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
FetchThreatListUpdatesRequest::list_update_requests() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_;
}

// optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
inline bool FetchThreatListUpdatesRequest::has_chrome_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest::set_has_chrome_client_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesRequest::clear_has_chrome_client_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesRequest::clear_chrome_client_info() {
  if (chrome_client_info_ != NULL) chrome_client_info_->::mozilla::safebrowsing::ChromeClientInfo::Clear();
  clear_has_chrome_client_info();
}
inline const ::mozilla::safebrowsing::ChromeClientInfo& FetchThreatListUpdatesRequest::chrome_client_info() const {
  const ::mozilla::safebrowsing::ChromeClientInfo* p = chrome_client_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ChromeClientInfo*>(
      &::mozilla::safebrowsing::_ChromeClientInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ChromeClientInfo* FetchThreatListUpdatesRequest::mutable_chrome_client_info() {
  set_has_chrome_client_info();
  if (chrome_client_info_ == NULL) {
    chrome_client_info_ = new ::mozilla::safebrowsing::ChromeClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return chrome_client_info_;
}
inline ::mozilla::safebrowsing::ChromeClientInfo* FetchThreatListUpdatesRequest::release_chrome_client_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  clear_has_chrome_client_info();
  ::mozilla::safebrowsing::ChromeClientInfo* temp = chrome_client_info_;
  chrome_client_info_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesRequest::set_allocated_chrome_client_info(::mozilla::safebrowsing::ChromeClientInfo* chrome_client_info) {
  delete chrome_client_info_;
  chrome_client_info_ = chrome_client_info;
  if (chrome_client_info) {
    set_has_chrome_client_info();
  } else {
    clear_has_chrome_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 3;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_response_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type() {
  response_type_ = 0;
  clear_has_response_type();
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
  return static_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(response_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  assert(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const {
  return additions_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions() {
  additions_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return &additions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_;
}

// repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const {
  return removals_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals() {
  removals_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return &removals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_;
}

// optional bytes new_client_state = 7;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_new_client_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_new_client_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state() {
  new_client_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_new_client_state();
}
inline const ::std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.GetNoArena();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const ::std::string& value) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
#if LANG_CXX11
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(::std::string&& value) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
#endif
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const void* value, size_t size) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline ::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state() {
  set_has_new_client_state();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  clear_has_new_client_state();
  return new_client_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(::std::string* new_client_state) {
  if (new_client_state != NULL) {
    set_has_new_client_state();
  } else {
    clear_has_new_client_state();
  }
  new_client_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_client_state);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .mozilla.safebrowsing.Checksum checksum = 8;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_checksum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum() {
  if (checksum_ != NULL) checksum_->::mozilla::safebrowsing::Checksum::Clear();
  clear_has_checksum();
}
inline const ::mozilla::safebrowsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const {
  const ::mozilla::safebrowsing::Checksum* p = checksum_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Checksum*>(
      &::mozilla::safebrowsing::_Checksum_default_instance_);
}
inline ::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == NULL) {
    checksum_ = new ::mozilla::safebrowsing::Checksum;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return checksum_;
}
inline ::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  clear_has_checksum();
  ::mozilla::safebrowsing::Checksum* temp = checksum_;
  checksum_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::mozilla::safebrowsing::Checksum* checksum) {
  delete checksum_;
  checksum_ = checksum;
  if (checksum) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
inline int FetchThreatListUpdatesResponse::list_update_responses_size() const {
  return list_update_responses_.size();
}
inline void FetchThreatListUpdatesResponse::clear_list_update_responses() {
  list_update_responses_.Clear();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Get(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Mutable(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
FetchThreatListUpdatesResponse::mutable_list_update_responses() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return &list_update_responses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
FetchThreatListUpdatesResponse::list_update_responses() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
inline bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
inline const ::mozilla::safebrowsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const {
  const ::mozilla::safebrowsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
inline ::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline ::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

// -------------------------------------------------------------------

// FindFullHashesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FindFullHashesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindFullHashesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindFullHashesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindFullHashesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FindFullHashesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FindFullHashesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
inline int FindFullHashesRequest::client_states_size() const {
  return client_states_.size();
}
inline void FindFullHashesRequest::clear_client_states() {
  client_states_.Clear();
}
inline const ::std::string& FindFullHashesRequest::client_states(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Get(index);
}
inline ::std::string* FindFullHashesRequest::mutable_client_states(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Mutable(index);
}
inline void FindFullHashesRequest::set_client_states(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FindFullHashesRequest::set_client_states(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FindFullHashesRequest::set_client_states(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size) {
  client_states_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline ::std::string* FindFullHashesRequest::add_client_states() {
  // @@protoc_insertion_point(field_add_mutable:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Add();
}
inline void FindFullHashesRequest::add_client_states(const ::std::string& value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
#if LANG_CXX11
inline void FindFullHashesRequest::add_client_states(::std::string&& value) {
  client_states_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
#endif
inline void FindFullHashesRequest::add_client_states(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const void* value, size_t size) {
  client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindFullHashesRequest::client_states() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindFullHashesRequest::mutable_client_states() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return &client_states_;
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
inline bool FindFullHashesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindFullHashesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindFullHashesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindFullHashesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
inline const ::mozilla::safebrowsing::ThreatInfo& FindFullHashesRequest::threat_info() const {
  const ::mozilla::safebrowsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatInfo*>(
      &::mozilla::safebrowsing::_ThreatInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  return threat_info_;
}
inline ::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
inline void FindFullHashesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindFullHashesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
inline int FindFullHashesResponse::matches_size() const {
  return matches_.size();
}
inline void FindFullHashesResponse::clear_matches() {
  matches_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatMatch& FindFullHashesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindFullHashesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return &matches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindFullHashesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
inline bool FindFullHashesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindFullHashesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindFullHashesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindFullHashesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
inline const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::minimum_wait_duration() const {
  const ::mozilla::safebrowsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
inline void FindFullHashesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
inline bool FindFullHashesResponse::has_negative_cache_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindFullHashesResponse::set_has_negative_cache_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindFullHashesResponse::clear_has_negative_cache_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindFullHashesResponse::clear_negative_cache_duration() {
  if (negative_cache_duration_ != NULL) negative_cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_negative_cache_duration();
}
inline const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::negative_cache_duration() const {
  const ::mozilla::safebrowsing::Duration* p = negative_cache_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration() {
  set_has_negative_cache_duration();
  if (negative_cache_duration_ == NULL) {
    negative_cache_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  return negative_cache_duration_;
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_negative_cache_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  clear_has_negative_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = NULL;
  return temp;
}
inline void FindFullHashesResponse::set_allocated_negative_cache_duration(::mozilla::safebrowsing::Duration* negative_cache_duration) {
  delete negative_cache_duration_;
  negative_cache_duration_ = negative_cache_duration;
  if (negative_cache_duration) {
    set_has_negative_cache_duration();
  } else {
    clear_has_negative_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
}

// -------------------------------------------------------------------

// ThreatHit_ThreatSource

// optional string url = 1;
inline bool ThreatHit_ThreatSource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatHit_ThreatSource::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatHit_ThreatSource::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ThreatHit_ThreatSource::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return url_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
#if LANG_CXX11
inline void ThreatHit_ThreatSource::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
#endif
inline void ThreatHit_ThreatSource::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatHit_ThreatSource::release_url() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}

// optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
inline bool ThreatHit_ThreatSource::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatHit_ThreatSource::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatHit_ThreatSource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
  return static_cast< ::mozilla::safebrowsing::ThreatHit_ThreatSourceType >(type_);
}
inline void ThreatHit_ThreatSource::set_type(::mozilla::safebrowsing::ThreatHit_ThreatSourceType value) {
  assert(::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
inline bool ThreatHit_ThreatSource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatHit_ThreatSource::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatHit_ThreatSource::clear_remote_ip() {
  remote_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remote_ip();
}
inline const ::std::string& ThreatHit_ThreatSource::remote_ip() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
#if LANG_CXX11
inline void ThreatHit_ThreatSource::set_remote_ip(::std::string&& value) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
#endif
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value, size_t size) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_remote_ip() {
  set_has_remote_ip();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatHit_ThreatSource::release_remote_ip() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  clear_has_remote_ip();
  return remote_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_remote_ip(::std::string* remote_ip) {
  if (remote_ip != NULL) {
    set_has_remote_ip();
  } else {
    clear_has_remote_ip();
  }
  remote_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
inline bool ThreatHit_ThreatSource::has_referrer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_referrer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatHit_ThreatSource::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatHit_ThreatSource::clear_referrer() {
  referrer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_referrer();
}
inline const ::std::string& ThreatHit_ThreatSource::referrer() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return referrer_.GetNoArena();
}
inline void ThreatHit_ThreatSource::set_referrer(const ::std::string& value) {
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
#if LANG_CXX11
inline void ThreatHit_ThreatSource::set_referrer(::std::string&& value) {
  set_has_referrer();
  referrer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
#endif
inline void ThreatHit_ThreatSource::set_referrer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_referrer() {
  set_has_referrer();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return referrer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatHit_ThreatSource::release_referrer() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  clear_has_referrer();
  return referrer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_ThreatSource::set_allocated_referrer(::std::string* referrer) {
  if (referrer != NULL) {
    set_has_referrer();
  } else {
    clear_has_referrer();
  }
  referrer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referrer);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}

// -------------------------------------------------------------------

// ThreatHit_UserInfo

// optional string region_code = 1;
inline bool ThreatHit_UserInfo::has_region_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit_UserInfo::set_has_region_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatHit_UserInfo::clear_has_region_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatHit_UserInfo::clear_region_code() {
  region_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_region_code();
}
inline const ::std::string& ThreatHit_UserInfo::region_code() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  return region_code_.GetNoArena();
}
inline void ThreatHit_UserInfo::set_region_code(const ::std::string& value) {
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
#if LANG_CXX11
inline void ThreatHit_UserInfo::set_region_code(::std::string&& value) {
  set_has_region_code();
  region_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
#endif
inline void ThreatHit_UserInfo::set_region_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
inline void ThreatHit_UserInfo::set_region_code(const char* value, size_t size) {
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
inline ::std::string* ThreatHit_UserInfo::mutable_region_code() {
  set_has_region_code();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  return region_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatHit_UserInfo::release_region_code() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  clear_has_region_code();
  return region_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_UserInfo::set_allocated_region_code(::std::string* region_code) {
  if (region_code != NULL) {
    set_has_region_code();
  } else {
    clear_has_region_code();
  }
  region_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region_code);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}

// optional bytes user_id = 2;
inline bool ThreatHit_UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit_UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatHit_UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatHit_UserInfo::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& ThreatHit_UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  return user_id_.GetNoArena();
}
inline void ThreatHit_UserInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
#if LANG_CXX11
inline void ThreatHit_UserInfo::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
#endif
inline void ThreatHit_UserInfo::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
inline void ThreatHit_UserInfo::set_user_id(const void* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
inline ::std::string* ThreatHit_UserInfo::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatHit_UserInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatHit_UserInfo::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}

// -------------------------------------------------------------------

// ThreatHit

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatHit::has_threat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatHit::set_has_threat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatHit::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatHit::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatHit::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatHit::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatHit::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatHit::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThreatHit::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThreatHit::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatHit::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatHit::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntry entry = 3;
inline bool ThreatHit::has_entry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit::set_has_entry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatHit::clear_has_entry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatHit::clear_entry() {
  if (entry_ != NULL) entry_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_entry();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatHit::entry() const {
  const ::mozilla::safebrowsing::ThreatEntry* p = entry_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.entry)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntry*>(
      &::mozilla::safebrowsing::_ThreatEntry_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatHit::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) {
    entry_ = new ::mozilla::safebrowsing::ThreatEntry;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.entry)
  return entry_;
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatHit::release_entry() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.entry)
  clear_has_entry();
  ::mozilla::safebrowsing::ThreatEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void ThreatHit::set_allocated_entry(::mozilla::safebrowsing::ThreatEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.entry)
}

// repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
inline int ThreatHit::resources_size() const {
  return resources_.size();
}
inline void ThreatHit::clear_resources() {
  resources_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::add_resources() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >*
ThreatHit::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatHit.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >&
ThreatHit::resources() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatHit.resources)
  return resources_;
}

// optional .mozilla.safebrowsing.ClientInfo client_info = 5;
inline bool ThreatHit::has_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit::set_has_client_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatHit::clear_has_client_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatHit::clear_client_info() {
  if (client_info_ != NULL) client_info_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client_info();
}
inline const ::mozilla::safebrowsing::ClientInfo& ThreatHit::client_info() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ClientInfo* ThreatHit::mutable_client_info() {
  set_has_client_info();
  if (client_info_ == NULL) {
    client_info_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.client_info)
  return client_info_;
}
inline ::mozilla::safebrowsing::ClientInfo* ThreatHit::release_client_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.client_info)
  clear_has_client_info();
  ::mozilla::safebrowsing::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline void ThreatHit::set_allocated_client_info(::mozilla::safebrowsing::ClientInfo* client_info) {
  delete client_info_;
  client_info_ = client_info;
  if (client_info) {
    set_has_client_info();
  } else {
    clear_has_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.client_info)
}

// optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
inline bool ThreatHit::has_user_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit::set_has_user_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatHit::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatHit::clear_user_info() {
  if (user_info_ != NULL) user_info_->::mozilla::safebrowsing::ThreatHit_UserInfo::Clear();
  clear_has_user_info();
}
inline const ::mozilla::safebrowsing::ThreatHit_UserInfo& ThreatHit::user_info() const {
  const ::mozilla::safebrowsing::ThreatHit_UserInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatHit_UserInfo*>(
      &::mozilla::safebrowsing::_ThreatHit_UserInfo_default_instance_);
}
inline ::mozilla::safebrowsing::ThreatHit_UserInfo* ThreatHit::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    user_info_ = new ::mozilla::safebrowsing::ThreatHit_UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.user_info)
  return user_info_;
}
inline ::mozilla::safebrowsing::ThreatHit_UserInfo* ThreatHit::release_user_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.user_info)
  clear_has_user_info();
  ::mozilla::safebrowsing::ThreatHit_UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void ThreatHit::set_allocated_user_info(::mozilla::safebrowsing::ThreatHit_UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.user_info)
}

// -------------------------------------------------------------------

// ClientInfo

// optional string client_id = 1;
inline bool ClientInfo::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfo::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInfo::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInfo::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& ClientInfo::client_id() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_id)
  return client_id_.GetNoArena();
}
inline void ClientInfo::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_id)
}
#if LANG_CXX11
inline void ClientInfo::set_client_id(::std::string&& value) {
  set_has_client_id();
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ClientInfo.client_id)
}
#endif
inline void ClientInfo::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_id)
}
inline ::std::string* ClientInfo::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ClientInfo.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInfo::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_id)
}

// optional string client_version = 2;
inline bool ClientInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfo::set_has_client_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInfo::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInfo::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_version();
}
inline const ::std::string& ClientInfo::client_version() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_version)
  return client_version_.GetNoArena();
}
inline void ClientInfo::set_client_version(const ::std::string& value) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_version)
}
#if LANG_CXX11
inline void ClientInfo::set_client_version(::std::string&& value) {
  set_has_client_version();
  client_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ClientInfo.client_version)
}
#endif
inline void ClientInfo::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_version)
}
inline ::std::string* ClientInfo::mutable_client_version() {
  set_has_client_version();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_version)
  return client_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ClientInfo.client_version)
  clear_has_client_version();
  return client_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInfo::set_allocated_client_version(::std::string* client_version) {
  if (client_version != NULL) {
    set_has_client_version();
  } else {
    clear_has_client_version();
  }
  client_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_version)
}

// -------------------------------------------------------------------

// ChromeClientInfo

// optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
inline bool ChromeClientInfo::has_reporting_population() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeClientInfo::set_has_reporting_population() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromeClientInfo::clear_has_reporting_population() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromeClientInfo::clear_reporting_population() {
  reporting_population_ = 0;
  clear_has_reporting_population();
}
inline ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::reporting_population() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ChromeClientInfo.reporting_population)
  return static_cast< ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation >(reporting_population_);
}
inline void ChromeClientInfo::set_reporting_population(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  assert(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value));
  set_has_reporting_population();
  reporting_population_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ChromeClientInfo.reporting_population)
}

// -------------------------------------------------------------------

// Checksum

// optional bytes sha256 = 1;
inline bool Checksum::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Checksum::set_has_sha256() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Checksum::clear_has_sha256() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Checksum::clear_sha256() {
  sha256_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sha256();
}
inline const ::std::string& Checksum::sha256() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Checksum.sha256)
  return sha256_.GetNoArena();
}
inline void Checksum::set_sha256(const ::std::string& value) {
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Checksum.sha256)
}
#if LANG_CXX11
inline void Checksum::set_sha256(::std::string&& value) {
  set_has_sha256();
  sha256_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.Checksum.sha256)
}
#endif
inline void Checksum::set_sha256(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.Checksum.sha256)
}
inline void Checksum::set_sha256(const void* value, size_t size) {
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.Checksum.sha256)
}
inline ::std::string* Checksum::mutable_sha256() {
  set_has_sha256();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.Checksum.sha256)
  return sha256_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Checksum::release_sha256() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.Checksum.sha256)
  clear_has_sha256();
  return sha256_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Checksum::set_allocated_sha256(::std::string* sha256) {
  if (sha256 != NULL) {
    set_has_sha256();
  } else {
    clear_has_sha256();
  }
  sha256_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.Checksum.sha256)
}

// -------------------------------------------------------------------

// ThreatEntry

// optional bytes hash = 1;
inline bool ThreatEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntry::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntry::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntry::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& ThreatEntry::hash() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.hash)
  return hash_.GetNoArena();
}
inline void ThreatEntry::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.hash)
}
#if LANG_CXX11
inline void ThreatEntry::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntry.hash)
}
#endif
inline void ThreatEntry::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.hash)
}
inline ::std::string* ThreatEntry::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatEntry::release_hash() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntry.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntry::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.hash)
}

// optional string url = 2;
inline bool ThreatEntry::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntry::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntry::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntry::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ThreatEntry::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.url)
  return url_.GetNoArena();
}
inline void ThreatEntry::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.url)
}
#if LANG_CXX11
inline void ThreatEntry::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntry.url)
}
#endif
inline void ThreatEntry::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.url)
}
inline ::std::string* ThreatEntry::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatEntry::release_url() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntry.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntry::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.url)
}

// -------------------------------------------------------------------

// ThreatEntrySet

// optional .mozilla.safebrowsing.CompressionType compression_type = 1;
inline bool ThreatEntrySet::has_compression_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatEntrySet::set_has_compression_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThreatEntrySet::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThreatEntrySet::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
inline ::mozilla::safebrowsing::CompressionType ThreatEntrySet::compression_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.compression_type)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(compression_type_);
}
inline void ThreatEntrySet::set_compression_type(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntrySet.compression_type)
}

// optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
inline bool ThreatEntrySet::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntrySet::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntrySet::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntrySet::clear_raw_hashes() {
  if (raw_hashes_ != NULL) raw_hashes_->::mozilla::safebrowsing::RawHashes::Clear();
  clear_has_raw_hashes();
}
inline const ::mozilla::safebrowsing::RawHashes& ThreatEntrySet::raw_hashes() const {
  const ::mozilla::safebrowsing::RawHashes* p = raw_hashes_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RawHashes*>(
      &::mozilla::safebrowsing::_RawHashes_default_instance_);
}
inline ::mozilla::safebrowsing::RawHashes* ThreatEntrySet::mutable_raw_hashes() {
  set_has_raw_hashes();
  if (raw_hashes_ == NULL) {
    raw_hashes_ = new ::mozilla::safebrowsing::RawHashes;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  return raw_hashes_;
}
inline ::mozilla::safebrowsing::RawHashes* ThreatEntrySet::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  clear_has_raw_hashes();
  ::mozilla::safebrowsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_raw_hashes(::mozilla::safebrowsing::RawHashes* raw_hashes) {
  delete raw_hashes_;
  raw_hashes_ = raw_hashes;
  if (raw_hashes) {
    set_has_raw_hashes();
  } else {
    clear_has_raw_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
}

// optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
inline bool ThreatEntrySet::has_raw_indices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntrySet::set_has_raw_indices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntrySet::clear_has_raw_indices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntrySet::clear_raw_indices() {
  if (raw_indices_ != NULL) raw_indices_->::mozilla::safebrowsing::RawIndices::Clear();
  clear_has_raw_indices();
}
inline const ::mozilla::safebrowsing::RawIndices& ThreatEntrySet::raw_indices() const {
  const ::mozilla::safebrowsing::RawIndices* p = raw_indices_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RawIndices*>(
      &::mozilla::safebrowsing::_RawIndices_default_instance_);
}
inline ::mozilla::safebrowsing::RawIndices* ThreatEntrySet::mutable_raw_indices() {
  set_has_raw_indices();
  if (raw_indices_ == NULL) {
    raw_indices_ = new ::mozilla::safebrowsing::RawIndices;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  return raw_indices_;
}
inline ::mozilla::safebrowsing::RawIndices* ThreatEntrySet::release_raw_indices() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  clear_has_raw_indices();
  ::mozilla::safebrowsing::RawIndices* temp = raw_indices_;
  raw_indices_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_raw_indices(::mozilla::safebrowsing::RawIndices* raw_indices) {
  delete raw_indices_;
  raw_indices_ = raw_indices;
  if (raw_indices) {
    set_has_raw_indices();
  } else {
    clear_has_raw_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
inline bool ThreatEntrySet::has_rice_hashes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatEntrySet::set_has_rice_hashes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatEntrySet::clear_has_rice_hashes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatEntrySet::clear_rice_hashes() {
  if (rice_hashes_ != NULL) rice_hashes_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_hashes();
}
inline const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const {
  const ::mozilla::safebrowsing::RiceDeltaEncoding* p = rice_hashes_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      &::mozilla::safebrowsing::_RiceDeltaEncoding_default_instance_);
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes() {
  set_has_rice_hashes();
  if (rice_hashes_ == NULL) {
    rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  return rice_hashes_;
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  clear_has_rice_hashes();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_rice_hashes(::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes) {
  delete rice_hashes_;
  rice_hashes_ = rice_hashes;
  if (rice_hashes) {
    set_has_rice_hashes();
  } else {
    clear_has_rice_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
inline bool ThreatEntrySet::has_rice_indices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatEntrySet::set_has_rice_indices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatEntrySet::clear_has_rice_indices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatEntrySet::clear_rice_indices() {
  if (rice_indices_ != NULL) rice_indices_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_indices();
}
inline const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const {
  const ::mozilla::safebrowsing::RiceDeltaEncoding* p = rice_indices_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      &::mozilla::safebrowsing::_RiceDeltaEncoding_default_instance_);
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices() {
  set_has_rice_indices();
  if (rice_indices_ == NULL) {
    rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  return rice_indices_;
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  clear_has_rice_indices();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_rice_indices(::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices) {
  delete rice_indices_;
  rice_indices_ = rice_indices;
  if (rice_indices) {
    set_has_rice_indices();
  } else {
    clear_has_rice_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
}

// -------------------------------------------------------------------

// RawIndices

// repeated int32 indices = 1;
inline int RawIndices::indices_size() const {
  return indices_.size();
}
inline void RawIndices::clear_indices() {
  indices_.Clear();
}
inline ::google::protobuf::int32 RawIndices::indices(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawIndices.indices)
  return indices_.Get(index);
}
inline void RawIndices::set_indices(int index, ::google::protobuf::int32 value) {
  indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawIndices.indices)
}
inline void RawIndices::add_indices(::google::protobuf::int32 value) {
  indices_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.RawIndices.indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RawIndices::indices() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.RawIndices.indices)
  return indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RawIndices::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.RawIndices.indices)
  return &indices_;
}

// -------------------------------------------------------------------

// RawHashes

// optional int32 prefix_size = 1;
inline bool RawHashes::has_prefix_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawHashes::set_has_prefix_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawHashes::clear_has_prefix_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawHashes::clear_prefix_size() {
  prefix_size_ = 0;
  clear_has_prefix_size();
}
inline ::google::protobuf::int32 RawHashes::prefix_size() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.prefix_size)
  return prefix_size_;
}
inline void RawHashes::set_prefix_size(::google::protobuf::int32 value) {
  set_has_prefix_size();
  prefix_size_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
inline bool RawHashes::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawHashes::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawHashes::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawHashes::clear_raw_hashes() {
  raw_hashes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_raw_hashes();
}
inline const ::std::string& RawHashes::raw_hashes() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.raw_hashes)
  return raw_hashes_.GetNoArena();
}
inline void RawHashes::set_raw_hashes(const ::std::string& value) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.raw_hashes)
}
#if LANG_CXX11
inline void RawHashes::set_raw_hashes(::std::string&& value) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.RawHashes.raw_hashes)
}
#endif
inline void RawHashes::set_raw_hashes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(const void* value, size_t size) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RawHashes.raw_hashes)
}
inline ::std::string* RawHashes::mutable_raw_hashes() {
  set_has_raw_hashes();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RawHashes.raw_hashes)
  return raw_hashes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawHashes::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.RawHashes.raw_hashes)
  clear_has_raw_hashes();
  return raw_hashes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawHashes::set_allocated_raw_hashes(::std::string* raw_hashes) {
  if (raw_hashes != NULL) {
    set_has_raw_hashes();
  } else {
    clear_has_raw_hashes();
  }
  raw_hashes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_hashes);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RawHashes.raw_hashes)
}

// -------------------------------------------------------------------

// RiceDeltaEncoding

// optional int64 first_value = 1;
inline bool RiceDeltaEncoding::has_first_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RiceDeltaEncoding::set_has_first_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RiceDeltaEncoding::clear_has_first_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RiceDeltaEncoding::clear_first_value() {
  first_value_ = GOOGLE_LONGLONG(0);
  clear_has_first_value();
}
inline ::google::protobuf::int64 RiceDeltaEncoding::first_value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
  return first_value_;
}
inline void RiceDeltaEncoding::set_first_value(::google::protobuf::int64 value) {
  set_has_first_value();
  first_value_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
inline bool RiceDeltaEncoding::has_rice_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RiceDeltaEncoding::set_has_rice_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RiceDeltaEncoding::clear_has_rice_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RiceDeltaEncoding::clear_rice_parameter() {
  rice_parameter_ = 0;
  clear_has_rice_parameter();
}
inline ::google::protobuf::int32 RiceDeltaEncoding::rice_parameter() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
  return rice_parameter_;
}
inline void RiceDeltaEncoding::set_rice_parameter(::google::protobuf::int32 value) {
  set_has_rice_parameter();
  rice_parameter_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
inline bool RiceDeltaEncoding::has_num_entries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RiceDeltaEncoding::set_has_num_entries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RiceDeltaEncoding::clear_has_num_entries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RiceDeltaEncoding::clear_num_entries() {
  num_entries_ = 0;
  clear_has_num_entries();
}
inline ::google::protobuf::int32 RiceDeltaEncoding::num_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
  return num_entries_;
}
inline void RiceDeltaEncoding::set_num_entries(::google::protobuf::int32 value) {
  set_has_num_entries();
  num_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
inline bool RiceDeltaEncoding::has_encoded_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RiceDeltaEncoding::set_has_encoded_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RiceDeltaEncoding::clear_has_encoded_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RiceDeltaEncoding::clear_encoded_data() {
  encoded_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encoded_data();
}
inline const ::std::string& RiceDeltaEncoding::encoded_data() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.GetNoArena();
}
inline void RiceDeltaEncoding::set_encoded_data(const ::std::string& value) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
#if LANG_CXX11
inline void RiceDeltaEncoding::set_encoded_data(::std::string&& value) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
#endif
inline void RiceDeltaEncoding::set_encoded_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(const void* value, size_t size) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
inline ::std::string* RiceDeltaEncoding::mutable_encoded_data() {
  set_has_encoded_data();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RiceDeltaEncoding::release_encoded_data() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  clear_has_encoded_data();
  return encoded_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RiceDeltaEncoding::set_allocated_encoded_data(::std::string* encoded_data) {
  if (encoded_data != NULL) {
    set_has_encoded_data();
  } else {
    clear_has_encoded_data();
  }
  encoded_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoded_data);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
inline bool ThreatEntryMetadata_MetadataEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ThreatEntryMetadata_MetadataEntry::key() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.GetNoArena();
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
#if LANG_CXX11
inline void ThreatEntryMetadata_MetadataEntry::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
#endif
inline void ThreatEntryMetadata_MetadataEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::release_key() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
inline bool ThreatEntryMetadata_MetadataEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ThreatEntryMetadata_MetadataEntry::value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.GetNoArena();
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
#if LANG_CXX11
inline void ThreatEntryMetadata_MetadataEntry::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
#endif
inline void ThreatEntryMetadata_MetadataEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::release_value() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata

// repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
inline int ThreatEntryMetadata::entries_size() const {
  return entries_.size();
}
inline void ThreatEntryMetadata::clear_entries() {
  entries_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >*
ThreatEntryMetadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >&
ThreatEntryMetadata::entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ThreatListDescriptor

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatListDescriptor::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatListDescriptor::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatListDescriptor::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatListDescriptor::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatListDescriptor::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatListDescriptor::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatListDescriptor::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatListDescriptor::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatListDescriptor::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatListDescriptor::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatListDescriptor::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatListDescriptor::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
inline bool ThreatListDescriptor::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatListDescriptor::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatListDescriptor::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatListDescriptor::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatListDescriptor::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
}

// -------------------------------------------------------------------

// ListThreatListsResponse

// repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
inline int ListThreatListsResponse::threat_lists_size() const {
  return threat_lists_.size();
}
inline void ListThreatListsResponse::clear_threat_lists() {
  threat_lists_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >*
ListThreatListsResponse::mutable_threat_lists() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return &threat_lists_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >&
ListThreatListsResponse::threat_lists() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_;
}

// -------------------------------------------------------------------

// Duration

// optional int64 seconds = 1;
inline bool Duration::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Duration::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Duration::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Duration::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::int64 Duration::seconds() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.seconds)
  return seconds_;
}
inline void Duration::set_seconds(::google::protobuf::int64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.seconds)
}

// optional int32 nanos = 2;
inline bool Duration::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Duration::set_has_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Duration::clear_has_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Duration::clear_nanos() {
  nanos_ = 0;
  clear_has_nanos();
}
inline ::google::protobuf::int32 Duration::nanos() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.nanos)
  return nanos_;
}
inline void Duration::set_nanos(::google::protobuf::int32 value) {
  set_has_nanos();
  nanos_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.nanos)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace safebrowsing
}  // namespace mozilla

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::ThreatHit_ThreatSourceType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::ThreatType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::PlatformType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::CompressionType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mozilla::safebrowsing::ThreatEntryType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_safebrowsing_2eproto__INCLUDED
