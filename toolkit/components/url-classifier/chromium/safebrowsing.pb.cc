// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "safebrowsing.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace mozilla {
namespace safebrowsing {
class ThreatInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatInfo>
     _instance;
} _ThreatInfo_default_instance_;
class ThreatMatchDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatMatch>
     _instance;
} _ThreatMatch_default_instance_;
class FindThreatMatchesRequestDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FindThreatMatchesRequest>
     _instance;
} _FindThreatMatchesRequest_default_instance_;
class FindThreatMatchesResponseDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FindThreatMatchesResponse>
     _instance;
} _FindThreatMatchesResponse_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>
     _instance;
} _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest_ListUpdateRequest>
     _instance;
} _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
class FetchThreatListUpdatesRequestDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest>
     _instance;
} _FetchThreatListUpdatesRequest_default_instance_;
class FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FetchThreatListUpdatesResponse_ListUpdateResponse>
     _instance;
} _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
class FetchThreatListUpdatesResponseDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FetchThreatListUpdatesResponse>
     _instance;
} _FetchThreatListUpdatesResponse_default_instance_;
class FindFullHashesRequestDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FindFullHashesRequest>
     _instance;
} _FindFullHashesRequest_default_instance_;
class FindFullHashesResponseDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<FindFullHashesResponse>
     _instance;
} _FindFullHashesResponse_default_instance_;
class ThreatHit_ThreatSourceDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatHit_ThreatSource>
     _instance;
} _ThreatHit_ThreatSource_default_instance_;
class ThreatHit_UserInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatHit_UserInfo>
     _instance;
} _ThreatHit_UserInfo_default_instance_;
class ThreatHitDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatHit>
     _instance;
} _ThreatHit_default_instance_;
class ClientInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ClientInfo>
     _instance;
} _ClientInfo_default_instance_;
class ChromeClientInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ChromeClientInfo>
     _instance;
} _ChromeClientInfo_default_instance_;
class ChecksumDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Checksum>
     _instance;
} _Checksum_default_instance_;
class ThreatEntryDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatEntry>
     _instance;
} _ThreatEntry_default_instance_;
class ThreatEntrySetDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatEntrySet>
     _instance;
} _ThreatEntrySet_default_instance_;
class RawIndicesDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RawIndices>
     _instance;
} _RawIndices_default_instance_;
class RawHashesDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RawHashes>
     _instance;
} _RawHashes_default_instance_;
class RiceDeltaEncodingDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RiceDeltaEncoding>
     _instance;
} _RiceDeltaEncoding_default_instance_;
class ThreatEntryMetadata_MetadataEntryDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatEntryMetadata_MetadataEntry>
     _instance;
} _ThreatEntryMetadata_MetadataEntry_default_instance_;
class ThreatEntryMetadataDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatEntryMetadata>
     _instance;
} _ThreatEntryMetadata_default_instance_;
class ThreatListDescriptorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ThreatListDescriptor>
     _instance;
} _ThreatListDescriptor_default_instance_;
class ListThreatListsResponseDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ListThreatListsResponse>
     _instance;
} _ListThreatListsResponse_default_instance_;
class DurationDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Duration>
     _instance;
} _Duration_default_instance_;

namespace protobuf_safebrowsing_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
};

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _ThreatInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatInfo_default_instance_);_ThreatMatch_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatMatch_default_instance_);_FindThreatMatchesRequest_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FindThreatMatchesRequest_default_instance_);_FindThreatMatchesResponse_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FindThreatMatchesResponse_default_instance_);_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_);_FetchThreatListUpdatesRequest_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FetchThreatListUpdatesRequest_default_instance_);_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_);_FetchThreatListUpdatesResponse_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FetchThreatListUpdatesResponse_default_instance_);_FindFullHashesRequest_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FindFullHashesRequest_default_instance_);_FindFullHashesResponse_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_FindFullHashesResponse_default_instance_);_ThreatHit_ThreatSource_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatHit_ThreatSource_default_instance_);_ThreatHit_UserInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatHit_UserInfo_default_instance_);_ThreatHit_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatHit_default_instance_);_ClientInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ClientInfo_default_instance_);_ChromeClientInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ChromeClientInfo_default_instance_);_Checksum_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Checksum_default_instance_);_ThreatEntry_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatEntry_default_instance_);_ThreatEntrySet_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatEntrySet_default_instance_);_RawIndices_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RawIndices_default_instance_);_RawHashes_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RawHashes_default_instance_);_RiceDeltaEncoding_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RiceDeltaEncoding_default_instance_);_ThreatEntryMetadata_MetadataEntry_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatEntryMetadata_MetadataEntry_default_instance_);_ThreatEntryMetadata_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatEntryMetadata_default_instance_);_ThreatListDescriptor_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ThreatListDescriptor_default_instance_);_ListThreatListsResponse_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ListThreatListsResponse_default_instance_);_Duration_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Duration_default_instance_);_ThreatMatch_default_instance_._instance.get_mutable()->threat_ = const_cast< ::mozilla::safebrowsing::ThreatEntry*>(
      ::mozilla::safebrowsing::ThreatEntry::internal_default_instance());
  _ThreatMatch_default_instance_._instance.get_mutable()->threat_entry_metadata_ = const_cast< ::mozilla::safebrowsing::ThreatEntryMetadata*>(
      ::mozilla::safebrowsing::ThreatEntryMetadata::internal_default_instance());
  _ThreatMatch_default_instance_._instance.get_mutable()->cache_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
  _FindThreatMatchesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  _FindThreatMatchesRequest_default_instance_._instance.get_mutable()->threat_info_ = const_cast< ::mozilla::safebrowsing::ThreatInfo*>(
      ::mozilla::safebrowsing::ThreatInfo::internal_default_instance());
  _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_._instance.get_mutable()->constraints_ = const_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::internal_default_instance());
  _FetchThreatListUpdatesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  _FetchThreatListUpdatesRequest_default_instance_._instance.get_mutable()->chrome_client_info_ = const_cast< ::mozilla::safebrowsing::ChromeClientInfo*>(
      ::mozilla::safebrowsing::ChromeClientInfo::internal_default_instance());
  _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_._instance.get_mutable()->checksum_ = const_cast< ::mozilla::safebrowsing::Checksum*>(
      ::mozilla::safebrowsing::Checksum::internal_default_instance());
  _FetchThreatListUpdatesResponse_default_instance_._instance.get_mutable()->minimum_wait_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
  _FindFullHashesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  _FindFullHashesRequest_default_instance_._instance.get_mutable()->threat_info_ = const_cast< ::mozilla::safebrowsing::ThreatInfo*>(
      ::mozilla::safebrowsing::ThreatInfo::internal_default_instance());
  _FindFullHashesResponse_default_instance_._instance.get_mutable()->minimum_wait_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
  _FindFullHashesResponse_default_instance_._instance.get_mutable()->negative_cache_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
  _ThreatHit_default_instance_._instance.get_mutable()->entry_ = const_cast< ::mozilla::safebrowsing::ThreatEntry*>(
      ::mozilla::safebrowsing::ThreatEntry::internal_default_instance());
  _ThreatHit_default_instance_._instance.get_mutable()->client_info_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  _ThreatHit_default_instance_._instance.get_mutable()->user_info_ = const_cast< ::mozilla::safebrowsing::ThreatHit_UserInfo*>(
      ::mozilla::safebrowsing::ThreatHit_UserInfo::internal_default_instance());
  _ThreatEntrySet_default_instance_._instance.get_mutable()->raw_hashes_ = const_cast< ::mozilla::safebrowsing::RawHashes*>(
      ::mozilla::safebrowsing::RawHashes::internal_default_instance());
  _ThreatEntrySet_default_instance_._instance.get_mutable()->raw_indices_ = const_cast< ::mozilla::safebrowsing::RawIndices*>(
      ::mozilla::safebrowsing::RawIndices::internal_default_instance());
  _ThreatEntrySet_default_instance_._instance.get_mutable()->rice_hashes_ = const_cast< ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      ::mozilla::safebrowsing::RiceDeltaEncoding::internal_default_instance());
  _ThreatEntrySet_default_instance_._instance.get_mutable()->rice_indices_ = const_cast< ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      ::mozilla::safebrowsing::RiceDeltaEncoding::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
namespace {
void AddDescriptorsImpl() {
  InitDefaults();
}
} // anonymous namespace

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}

}  // namespace protobuf_safebrowsing_2eproto

bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::RESPONSE_TYPE_UNSPECIFIED;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::PARTIAL_UPDATE;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::FULL_UPDATE;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MIN;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MAX;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ThreatHit_ThreatSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ThreatHit_ThreatSourceType ThreatHit::THREAT_SOURCE_TYPE_UNSPECIFIED;
const ThreatHit_ThreatSourceType ThreatHit::MATCHING_URL;
const ThreatHit_ThreatSourceType ThreatHit::TAB_URL;
const ThreatHit_ThreatSourceType ThreatHit::TAB_REDIRECT;
const ThreatHit_ThreatSourceType ThreatHit::TAB_RESOURCE;
const ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MIN;
const ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MAX;
const int ThreatHit::ThreatSourceType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::UNSPECIFIED;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::OPT_OUT;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::EXTENDED;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SCOUT;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MIN;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MAX;
const int ChromeClientInfo::SafeBrowsingReportingPopulation_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ThreatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
      return true;
    default:
      return false;
  }
}

bool PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ThreatEntryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatInfo::kThreatTypesFieldNumber;
const int ThreatInfo::kPlatformTypesFieldNumber;
const int ThreatInfo::kThreatEntryTypesFieldNumber;
const int ThreatInfo::kThreatEntriesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatInfo::ThreatInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatInfo)
}
ThreatInfo::ThreatInfo(const ThreatInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      threat_types_(from.threat_types_),
      platform_types_(from.platform_types_),
      threat_entries_(from.threat_entries_),
      threat_entry_types_(from.threat_entry_types_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatInfo)
}

void ThreatInfo::SharedCtor() {
  _cached_size_ = 0;
}

ThreatInfo::~ThreatInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatInfo)
  SharedDtor();
}

void ThreatInfo::SharedDtor() {
}

void ThreatInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatInfo& ThreatInfo::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatInfo* ThreatInfo::New(::google::protobuf::Arena* arena) const {
  ThreatInfo* n = new ThreatInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_types_.Clear();
  platform_types_.Clear();
  threat_entries_.Clear();
  threat_entry_types_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            add_threat_types(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::mozilla::safebrowsing::ThreatType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_threat_types())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            add_platform_types(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::mozilla::safebrowsing::PlatformType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_platform_types())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_threat_entries()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatEntryType_IsValid(value)) {
            add_threat_entry_types(static_cast< ::mozilla::safebrowsing::ThreatEntryType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 4,
                 ::mozilla::safebrowsing::ThreatEntryType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_threat_entry_types())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatInfo)
  return false;
#undef DO_
}

void ThreatInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  for (int i = 0, n = this->threat_types_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_types(i), output);
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  for (int i = 0, n = this->platform_types_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->platform_types(i), output);
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->threat_entries_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->threat_entries(static_cast<int>(i)), output);
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  for (int i = 0, n = this->threat_entry_types_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->threat_entry_types(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatInfo)
}

size_t ThreatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->threat_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->threat_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->platform_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->platform_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->threat_entries_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->threat_entries(static_cast<int>(i)));
    }
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->threat_entry_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->threat_entry_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatInfo*>(&from));
}

void ThreatInfo::MergeFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  threat_types_.MergeFrom(from.threat_types_);
  platform_types_.MergeFrom(from.platform_types_);
  threat_entries_.MergeFrom(from.threat_entries_);
  threat_entry_types_.MergeFrom(from.threat_entry_types_);
}

void ThreatInfo::CopyFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatInfo::IsInitialized() const {
  return true;
}

void ThreatInfo::Swap(ThreatInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatInfo::InternalSwap(ThreatInfo* other) {
  using std::swap;
  threat_types_.InternalSwap(&other->threat_types_);
  platform_types_.InternalSwap(&other->platform_types_);
  threat_entries_.InternalSwap(&other->threat_entries_);
  threat_entry_types_.InternalSwap(&other->threat_entry_types_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatInfo

// repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
int ThreatInfo::threat_types_size() const {
  return threat_types_.size();
}
void ThreatInfo::clear_threat_types() {
  threat_types_.Clear();
}
::mozilla::safebrowsing::ThreatType ThreatInfo::threat_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_types)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_types_.Get(index));
}
void ThreatInfo::set_threat_types(int index, ::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_types)
}
void ThreatInfo::add_threat_types(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return threat_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return &threat_types_;
}

// repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
int ThreatInfo::platform_types_size() const {
  return platform_types_.size();
}
void ThreatInfo::clear_platform_types() {
  platform_types_.Clear();
}
::mozilla::safebrowsing::PlatformType ThreatInfo::platform_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.platform_types)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_types_.Get(index));
}
void ThreatInfo::set_platform_types(int index, ::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.platform_types)
}
void ThreatInfo::add_platform_types(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.platform_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::platform_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return platform_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_platform_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return &platform_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
int ThreatInfo::threat_entry_types_size() const {
  return threat_entry_types_.size();
}
void ThreatInfo::clear_threat_entry_types() {
  threat_entry_types_.Clear();
}
::mozilla::safebrowsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_types_.Get(index));
}
void ThreatInfo::set_threat_entry_types(int index, ::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
void ThreatInfo::add_threat_entry_types(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_entry_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return threat_entry_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return &threat_entry_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
int ThreatInfo::threat_entries_size() const {
  return threat_entries_.size();
}
void ThreatInfo::clear_threat_entries() {
  threat_entries_.Clear();
}
const ::mozilla::safebrowsing::ThreatEntry& ThreatInfo::threat_entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Get(index);
}
::mozilla::safebrowsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Mutable(index);
}
::mozilla::safebrowsing::ThreatEntry* ThreatInfo::add_threat_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >*
ThreatInfo::mutable_threat_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return &threat_entries_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >&
ThreatInfo::threat_entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatMatch::kThreatTypeFieldNumber;
const int ThreatMatch::kPlatformTypeFieldNumber;
const int ThreatMatch::kThreatEntryTypeFieldNumber;
const int ThreatMatch::kThreatFieldNumber;
const int ThreatMatch::kThreatEntryMetadataFieldNumber;
const int ThreatMatch::kCacheDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatMatch::ThreatMatch()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatMatch)
}
ThreatMatch::ThreatMatch(const ThreatMatch& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_threat()) {
    threat_ = new ::mozilla::safebrowsing::ThreatEntry(*from.threat_);
  } else {
    threat_ = NULL;
  }
  if (from.has_threat_entry_metadata()) {
    threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata(*from.threat_entry_metadata_);
  } else {
    threat_entry_metadata_ = NULL;
  }
  if (from.has_cache_duration()) {
    cache_duration_ = new ::mozilla::safebrowsing::Duration(*from.cache_duration_);
  } else {
    cache_duration_ = NULL;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatMatch)
}

void ThreatMatch::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&threat_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&threat_)) + sizeof(threat_entry_type_));
}

ThreatMatch::~ThreatMatch() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatMatch)
  SharedDtor();
}

void ThreatMatch::SharedDtor() {
  if (this != internal_default_instance()) delete threat_;
  if (this != internal_default_instance()) delete threat_entry_metadata_;
  if (this != internal_default_instance()) delete cache_duration_;
}

void ThreatMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatMatch& ThreatMatch::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatMatch* ThreatMatch::New(::google::protobuf::Arena* arena) const {
  ThreatMatch* n = new ThreatMatch;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatMatch)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(threat_ != NULL);
      threat_->::mozilla::safebrowsing::ThreatEntry::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_entry_metadata_ != NULL);
      threat_entry_metadata_->::mozilla::safebrowsing::ThreatEntryMetadata::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cache_duration_ != NULL);
      cache_duration_->::mozilla::safebrowsing::Duration::Clear();
    }
  }
  if (cached_has_bits & 56u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            set_threat_type(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            set_platform_type(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_threat()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_threat_entry_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.Duration cache_duration = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cache_duration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatEntryType_IsValid(value)) {
            set_threat_entry_type(static_cast< ::mozilla::safebrowsing::ThreatEntryType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(48u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatMatch)
  return false;
#undef DO_
}

void ThreatMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatMatch)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_type(), output);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->platform_type(), output);
  }

  // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->threat_, output);
  }

  // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->threat_entry_metadata_, output);
  }

  // optional .mozilla.safebrowsing.Duration cache_duration = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->cache_duration_, output);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->threat_entry_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatMatch)
}

size_t ThreatMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatMatch)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 63u) {
    // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
    if (has_threat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->threat_);
    }

    // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
    if (has_threat_entry_metadata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->threat_entry_metadata_);
    }

    // optional .mozilla.safebrowsing.Duration cache_duration = 5;
    if (has_cache_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cache_duration_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
    if (has_threat_entry_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatMatch*>(&from));
}

void ThreatMatch::MergeFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatMatch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_threat()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(from.threat());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_threat_entry_metadata()->::mozilla::safebrowsing::ThreatEntryMetadata::MergeFrom(from.threat_entry_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from.cache_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatMatch::CopyFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatMatch::IsInitialized() const {
  return true;
}

void ThreatMatch::Swap(ThreatMatch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatMatch::InternalSwap(ThreatMatch* other) {
  using std::swap;
  swap(threat_, other->threat_);
  swap(threat_entry_metadata_, other->threat_entry_metadata_);
  swap(cache_duration_, other->cache_duration_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatMatch::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatMatch";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatMatch

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
bool ThreatMatch::has_threat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatMatch::set_has_threat_type() {
  _has_bits_[0] |= 0x00000008u;
}
void ThreatMatch::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void ThreatMatch::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
::mozilla::safebrowsing::ThreatType ThreatMatch::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
void ThreatMatch::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
bool ThreatMatch::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ThreatMatch::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
void ThreatMatch::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void ThreatMatch::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
::mozilla::safebrowsing::PlatformType ThreatMatch::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
void ThreatMatch::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
bool ThreatMatch::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ThreatMatch::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000020u;
}
void ThreatMatch::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000020u;
}
void ThreatMatch::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
::mozilla::safebrowsing::ThreatEntryType ThreatMatch::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
void ThreatMatch::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
}

// optional .mozilla.safebrowsing.ThreatEntry threat = 3;
bool ThreatMatch::has_threat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatMatch::set_has_threat() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatMatch::clear_has_threat() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatMatch::clear_threat() {
  if (threat_ != NULL) threat_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_threat();
}
const ::mozilla::safebrowsing::ThreatEntry& ThreatMatch::threat() const {
  const ::mozilla::safebrowsing::ThreatEntry* p = threat_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntry*>(
      &::mozilla::safebrowsing::_ThreatEntry_default_instance_);
}
::mozilla::safebrowsing::ThreatEntry* ThreatMatch::mutable_threat() {
  set_has_threat();
  if (threat_ == NULL) {
    threat_ = new ::mozilla::safebrowsing::ThreatEntry;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat)
  return threat_;
}
::mozilla::safebrowsing::ThreatEntry* ThreatMatch::release_threat() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.threat)
  clear_has_threat();
  ::mozilla::safebrowsing::ThreatEntry* temp = threat_;
  threat_ = NULL;
  return temp;
}
void ThreatMatch::set_allocated_threat(::mozilla::safebrowsing::ThreatEntry* threat) {
  delete threat_;
  threat_ = threat;
  if (threat) {
    set_has_threat();
  } else {
    clear_has_threat();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat)
}

// optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
bool ThreatMatch::has_threat_entry_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatMatch::set_has_threat_entry_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatMatch::clear_has_threat_entry_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatMatch::clear_threat_entry_metadata() {
  if (threat_entry_metadata_ != NULL) threat_entry_metadata_->::mozilla::safebrowsing::ThreatEntryMetadata::Clear();
  clear_has_threat_entry_metadata();
}
const ::mozilla::safebrowsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const {
  const ::mozilla::safebrowsing::ThreatEntryMetadata* p = threat_entry_metadata_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntryMetadata*>(
      &::mozilla::safebrowsing::_ThreatEntryMetadata_default_instance_);
}
::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata() {
  set_has_threat_entry_metadata();
  if (threat_entry_metadata_ == NULL) {
    threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  return threat_entry_metadata_;
}
::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  clear_has_threat_entry_metadata();
  ::mozilla::safebrowsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = NULL;
  return temp;
}
void ThreatMatch::set_allocated_threat_entry_metadata(::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata) {
  delete threat_entry_metadata_;
  threat_entry_metadata_ = threat_entry_metadata;
  if (threat_entry_metadata) {
    set_has_threat_entry_metadata();
  } else {
    clear_has_threat_entry_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
}

// optional .mozilla.safebrowsing.Duration cache_duration = 5;
bool ThreatMatch::has_cache_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatMatch::set_has_cache_duration() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreatMatch::clear_has_cache_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreatMatch::clear_cache_duration() {
  if (cache_duration_ != NULL) cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_cache_duration();
}
const ::mozilla::safebrowsing::Duration& ThreatMatch::cache_duration() const {
  const ::mozilla::safebrowsing::Duration* p = cache_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.cache_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
::mozilla::safebrowsing::Duration* ThreatMatch::mutable_cache_duration() {
  set_has_cache_duration();
  if (cache_duration_ == NULL) {
    cache_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.cache_duration)
  return cache_duration_;
}
::mozilla::safebrowsing::Duration* ThreatMatch::release_cache_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatMatch.cache_duration)
  clear_has_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = cache_duration_;
  cache_duration_ = NULL;
  return temp;
}
void ThreatMatch::set_allocated_cache_duration(::mozilla::safebrowsing::Duration* cache_duration) {
  delete cache_duration_;
  cache_duration_ = cache_duration;
  if (cache_duration) {
    set_has_cache_duration();
  } else {
    clear_has_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.cache_duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindThreatMatchesRequest::kClientFieldNumber;
const int FindThreatMatchesRequest::kThreatInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindThreatMatchesRequest::FindThreatMatchesRequest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}
FindThreatMatchesRequest::FindThreatMatchesRequest(const FindThreatMatchesRequest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = NULL;
  }
  if (from.has_threat_info()) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}

void FindThreatMatchesRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindThreatMatchesRequest::~FindThreatMatchesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesRequest)
  SharedDtor();
}

void FindThreatMatchesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindThreatMatchesRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindThreatMatchesRequest& FindThreatMatchesRequest::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FindThreatMatchesRequest* FindThreatMatchesRequest::New(::google::protobuf::Arena* arena) const {
  FindThreatMatchesRequest* n = new FindThreatMatchesRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindThreatMatchesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != NULL);
      client_->::mozilla::safebrowsing::ClientInfo::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != NULL);
      threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FindThreatMatchesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_threat_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FindThreatMatchesRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FindThreatMatchesRequest)
  return false;
#undef DO_
}

void FindThreatMatchesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->client_, output);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->threat_info_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FindThreatMatchesRequest)
}

size_t FindThreatMatchesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
    if (has_threat_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->threat_info_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindThreatMatchesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindThreatMatchesRequest*>(&from));
}

void FindThreatMatchesRequest::MergeFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from.client());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(from.threat_info());
    }
  }
}

void FindThreatMatchesRequest::CopyFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesRequest::IsInitialized() const {
  return true;
}

void FindThreatMatchesRequest::Swap(FindThreatMatchesRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindThreatMatchesRequest::InternalSwap(FindThreatMatchesRequest* other) {
  using std::swap;
  swap(client_, other->client_);
  swap(threat_info_, other->threat_info_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FindThreatMatchesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindThreatMatchesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
bool FindThreatMatchesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindThreatMatchesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
void FindThreatMatchesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindThreatMatchesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
const ::mozilla::safebrowsing::ClientInfo& FindThreatMatchesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  return client_;
}
::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
void FindThreatMatchesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.client)
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
bool FindThreatMatchesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindThreatMatchesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000002u;
}
void FindThreatMatchesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
}
void FindThreatMatchesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
const ::mozilla::safebrowsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const {
  const ::mozilla::safebrowsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatInfo*>(
      &::mozilla::safebrowsing::_ThreatInfo_default_instance_);
}
::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  return threat_info_;
}
::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
void FindThreatMatchesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindThreatMatchesResponse::kMatchesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindThreatMatchesResponse::FindThreatMatchesResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}
FindThreatMatchesResponse::FindThreatMatchesResponse(const FindThreatMatchesResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}

void FindThreatMatchesResponse::SharedCtor() {
  _cached_size_ = 0;
}

FindThreatMatchesResponse::~FindThreatMatchesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesResponse)
  SharedDtor();
}

void FindThreatMatchesResponse::SharedDtor() {
}

void FindThreatMatchesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindThreatMatchesResponse& FindThreatMatchesResponse::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FindThreatMatchesResponse* FindThreatMatchesResponse::New(::google::protobuf::Arena* arena) const {
  FindThreatMatchesResponse* n = new FindThreatMatchesResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindThreatMatchesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FindThreatMatchesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_matches()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FindThreatMatchesResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FindThreatMatchesResponse)
  return false;
#undef DO_
}

void FindThreatMatchesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->matches_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->matches(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FindThreatMatchesResponse)
}

size_t FindThreatMatchesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->matches_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matches(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindThreatMatchesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindThreatMatchesResponse*>(&from));
}

void FindThreatMatchesResponse::MergeFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
}

void FindThreatMatchesResponse::CopyFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesResponse::IsInitialized() const {
  return true;
}

void FindThreatMatchesResponse::Swap(FindThreatMatchesResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindThreatMatchesResponse::InternalSwap(FindThreatMatchesResponse* other) {
  using std::swap;
  matches_.InternalSwap(&other->matches_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FindThreatMatchesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindThreatMatchesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
int FindThreatMatchesResponse::matches_size() const {
  return matches_.size();
}
void FindThreatMatchesResponse::clear_matches() {
  matches_.Clear();
}
const ::mozilla::safebrowsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Get(index);
}
::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Mutable(index);
}
::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindThreatMatchesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return &matches_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindThreatMatchesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kMaxUpdateEntriesFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kMaxDatabaseEntriesFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kRegionFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kSupportedCompressionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      supported_compressions_(from.supported_compressions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  region_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_region()) {
    region_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.region_);
  }
  ::memcpy(&max_update_entries_, &from.max_update_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_database_entries_) -
    reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedCtor() {
  _cached_size_ = 0;
  region_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&max_update_entries_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_database_entries_) -
      reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedDtor() {
  region_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::New(::google::protobuf::Arena* arena) const {
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* n = new FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_compressions_.Clear();
  if (has_region()) {
    GOOGLE_DCHECK(!region_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*region_.UnsafeRawStringPointer())->clear();
  }
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 6u) {
    ::memset(&max_update_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_database_entries_) -
        reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 max_update_entries = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_max_update_entries();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_update_entries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_database_entries = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_max_database_entries();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_database_entries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string region = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_region()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::CompressionType_IsValid(value)) {
            add_supported_compressions(static_cast< ::mozilla::safebrowsing::CompressionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 4,
                 ::mozilla::safebrowsing::CompressionType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_supported_compressions())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  return false;
#undef DO_
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 max_update_entries = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->max_update_entries(), output);
  }

  // optional int32 max_database_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_database_entries(), output);
  }

  // optional string region = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->region(), output);
  }

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  for (int i = 0, n = this->supported_compressions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->supported_compressions(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->supported_compressions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->supported_compressions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional string region = 3;
    if (has_region()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->region());
    }

    // optional int32 max_update_entries = 1;
    if (has_max_update_entries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_update_entries());
    }

    // optional int32 max_database_entries = 2;
    if (has_max_database_entries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_database_entries());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(&from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  supported_compressions_.MergeFrom(from.supported_compressions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_region();
      region_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.region_);
    }
    if (cached_has_bits & 0x00000002u) {
      max_update_entries_ = from.max_update_entries_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_database_entries_ = from.max_database_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
  using std::swap;
  supported_compressions_.InternalSwap(&other->supported_compressions_);
  region_.Swap(&other->region_);
  swap(max_update_entries_, other->max_update_entries_);
  swap(max_database_entries_, other->max_database_entries_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_update_entries() {
  _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_update_entries() {
  _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries() {
  max_update_entries_ = 0;
  clear_has_max_update_entries();
}
::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
  return max_update_entries_;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(::google::protobuf::int32 value) {
  set_has_max_update_entries();
  max_update_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_database_entries() {
  _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_database_entries() {
  _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries() {
  max_database_entries_ = 0;
  clear_has_max_database_entries();
}
::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
  return max_database_entries_;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(::google::protobuf::int32 value) {
  set_has_max_database_entries();
  max_database_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region() {
  region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_region();
}
const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.GetNoArena();
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const ::std::string& value) {
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
#if LANG_CXX11
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(::std::string&& value) {
  set_has_region();
  region_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
#endif
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value, size_t size) {
  set_has_region();
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region() {
  set_has_region();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  clear_has_region();
  return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(::std::string* region) {
  if (region != NULL) {
    set_has_region();
  } else {
    clear_has_region();
  }
  region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const {
  return supported_compressions_.size();
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions() {
  supported_compressions_.Clear();
}
::mozilla::safebrowsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(supported_compressions_.Get(index));
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
const ::google::protobuf::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return supported_compressions_;
}
::google::protobuf::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return &supported_compressions_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kThreatTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kPlatformTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kThreatEntryTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kStateFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kConstraintsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_state()) {
    state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
  }
  if (from.has_constraints()) {
    constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(*from.constraints_);
  } else {
    constraints_ = NULL;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedCtor() {
  _cached_size_ = 0;
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&constraints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&constraints_)) + sizeof(threat_entry_type_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest::~FetchThreatListUpdatesRequest_ListUpdateRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedDtor() {
  state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete constraints_;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest_ListUpdateRequest::New(::google::protobuf::Arena* arena) const {
  FetchThreatListUpdatesRequest_ListUpdateRequest* n = new FetchThreatListUpdatesRequest_ListUpdateRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!state_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*state_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(constraints_ != NULL);
      constraints_->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
    }
  }
  if (cached_has_bits & 28u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            set_threat_type(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            set_platform_type(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes state = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_state()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_constraints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatEntryType_IsValid(value)) {
            set_threat_entry_type(static_cast< ::mozilla::safebrowsing::ThreatEntryType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  return false;
#undef DO_
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_type(), output);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->platform_type(), output);
  }

  // optional bytes state = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->state(), output);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->constraints_, output);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->threat_entry_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    // optional bytes state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->state());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
    if (has_constraints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->constraints_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
    if (has_threat_entry_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(&from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_state();
      state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_constraints()->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(from.constraints());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
  using std::swap;
  state_.Swap(&other->state_);
  swap(constraints_, other->constraints_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest_ListUpdateRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_type() {
  _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_platform_type() {
  _has_bits_[0] |= 0x00000008u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000010u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.GetNoArena();
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
#if LANG_CXX11
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(::std::string&& value) {
  set_has_state();
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
#endif
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const void* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_constraints() {
  _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_constraints() {
  _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints() {
  if (constraints_ != NULL) constraints_->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
  clear_has_constraints();
}
const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const {
  const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* p = constraints_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
}
::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints() {
  set_has_constraints();
  if (constraints_ == NULL) {
    constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return constraints_;
}
::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  clear_has_constraints();
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = NULL;
  return temp;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  delete constraints_;
  constraints_ = constraints;
  if (constraints) {
    set_has_constraints();
  } else {
    clear_has_constraints();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest::kClientFieldNumber;
const int FetchThreatListUpdatesRequest::kListUpdateRequestsFieldNumber;
const int FetchThreatListUpdatesRequest::kChromeClientInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      list_update_requests_(from.list_update_requests_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = NULL;
  }
  if (from.has_chrome_client_info()) {
    chrome_client_info_ = new ::mozilla::safebrowsing::ChromeClientInfo(*from.chrome_client_info_);
  } else {
    chrome_client_info_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}

void FetchThreatListUpdatesRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chrome_client_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(chrome_client_info_));
}

FetchThreatListUpdatesRequest::~FetchThreatListUpdatesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  SharedDtor();
}

void FetchThreatListUpdatesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete chrome_client_info_;
}

void FetchThreatListUpdatesRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest& FetchThreatListUpdatesRequest::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FetchThreatListUpdatesRequest* FetchThreatListUpdatesRequest::New(::google::protobuf::Arena* arena) const {
  FetchThreatListUpdatesRequest* n = new FetchThreatListUpdatesRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FetchThreatListUpdatesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_requests_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != NULL);
      client_->::mozilla::safebrowsing::ClientInfo::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(chrome_client_info_ != NULL);
      chrome_client_info_->::mozilla::safebrowsing::ChromeClientInfo::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FetchThreatListUpdatesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list_update_requests()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_chrome_client_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  return false;
#undef DO_
}

void FetchThreatListUpdatesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->client_, output);
  }

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_update_requests_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->list_update_requests(static_cast<int>(i)), output);
  }

  // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->chrome_client_info_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}

size_t FetchThreatListUpdatesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->list_update_requests_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->list_update_requests(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_);
    }

    // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
    if (has_chrome_client_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->chrome_client_info_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchThreatListUpdatesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest*>(&from));
}

void FetchThreatListUpdatesRequest::MergeFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_requests_.MergeFrom(from.list_update_requests_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from.client());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_chrome_client_info()->::mozilla::safebrowsing::ChromeClientInfo::MergeFrom(from.chrome_client_info());
    }
  }
}

void FetchThreatListUpdatesRequest::CopyFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest::Swap(FetchThreatListUpdatesRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FetchThreatListUpdatesRequest::InternalSwap(FetchThreatListUpdatesRequest* other) {
  using std::swap;
  list_update_requests_.InternalSwap(&other->list_update_requests_);
  swap(client_, other->client_);
  swap(chrome_client_info_, other->chrome_client_info_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
bool FetchThreatListUpdatesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
const ::mozilla::safebrowsing::ClientInfo& FetchThreatListUpdatesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  return client_;
}
::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
void FetchThreatListUpdatesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
}

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
int FetchThreatListUpdatesRequest::list_update_requests_size() const {
  return list_update_requests_.size();
}
void FetchThreatListUpdatesRequest::clear_list_update_requests() {
  list_update_requests_.Clear();
}
const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Get(index);
}
::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Mutable(index);
}
::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
FetchThreatListUpdatesRequest::mutable_list_update_requests() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return &list_update_requests_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
FetchThreatListUpdatesRequest::list_update_requests() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_;
}

// optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
bool FetchThreatListUpdatesRequest::has_chrome_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesRequest::set_has_chrome_client_info() {
  _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesRequest::clear_has_chrome_client_info() {
  _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesRequest::clear_chrome_client_info() {
  if (chrome_client_info_ != NULL) chrome_client_info_->::mozilla::safebrowsing::ChromeClientInfo::Clear();
  clear_has_chrome_client_info();
}
const ::mozilla::safebrowsing::ChromeClientInfo& FetchThreatListUpdatesRequest::chrome_client_info() const {
  const ::mozilla::safebrowsing::ChromeClientInfo* p = chrome_client_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ChromeClientInfo*>(
      &::mozilla::safebrowsing::_ChromeClientInfo_default_instance_);
}
::mozilla::safebrowsing::ChromeClientInfo* FetchThreatListUpdatesRequest::mutable_chrome_client_info() {
  set_has_chrome_client_info();
  if (chrome_client_info_ == NULL) {
    chrome_client_info_ = new ::mozilla::safebrowsing::ChromeClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return chrome_client_info_;
}
::mozilla::safebrowsing::ChromeClientInfo* FetchThreatListUpdatesRequest::release_chrome_client_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
  clear_has_chrome_client_info();
  ::mozilla::safebrowsing::ChromeClientInfo* temp = chrome_client_info_;
  chrome_client_info_ = NULL;
  return temp;
}
void FetchThreatListUpdatesRequest::set_allocated_chrome_client_info(::mozilla::safebrowsing::ChromeClientInfo* chrome_client_info) {
  delete chrome_client_info_;
  chrome_client_info_ = chrome_client_info;
  if (chrome_client_info) {
    set_has_chrome_client_info();
  } else {
    clear_has_chrome_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.chrome_client_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kThreatTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kThreatEntryTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kPlatformTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kResponseTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kAdditionsFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kRemovalsFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kNewClientStateFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kChecksumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      additions_(from.additions_),
      removals_(from.removals_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  new_client_state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_new_client_state()) {
    new_client_state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_client_state_);
  }
  if (from.has_checksum()) {
    checksum_ = new ::mozilla::safebrowsing::Checksum(*from.checksum_);
  } else {
    checksum_ = NULL;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedCtor() {
  _cached_size_ = 0;
  new_client_state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&checksum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&response_type_) -
      reinterpret_cast<char*>(&checksum_)) + sizeof(response_type_));
}

FetchThreatListUpdatesResponse_ListUpdateResponse::~FetchThreatListUpdatesResponse_ListUpdateResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  SharedDtor();
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedDtor() {
  new_client_state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete checksum_;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse_ListUpdateResponse::New(::google::protobuf::Arena* arena) const {
  FetchThreatListUpdatesResponse_ListUpdateResponse* n = new FetchThreatListUpdatesResponse_ListUpdateResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additions_.Clear();
  removals_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!new_client_state_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*new_client_state_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(checksum_ != NULL);
      checksum_->::mozilla::safebrowsing::Checksum::Clear();
    }
  }
  if (cached_has_bits & 60u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&response_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            set_threat_type(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatEntryType_IsValid(value)) {
            set_threat_entry_type(static_cast< ::mozilla::safebrowsing::ThreatEntryType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            set_platform_type(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value)) {
            set_response_type(static_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_additions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_removals()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes new_client_state = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_new_client_state()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.Checksum checksum = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checksum()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  return false;
#undef DO_
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_type(), output);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->threat_entry_type(), output);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->platform_type(), output);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->response_type(), output);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->additions_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->additions(static_cast<int>(i)), output);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->removals_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->removals(static_cast<int>(i)), output);
  }

  // optional bytes new_client_state = 7;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->new_client_state(), output);
  }

  // optional .mozilla.safebrowsing.Checksum checksum = 8;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->checksum_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

size_t FetchThreatListUpdatesResponse_ListUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->additions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->additions(static_cast<int>(i)));
    }
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->removals_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->removals(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 63u) {
    // optional bytes new_client_state = 7;
    if (has_new_client_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->new_client_state());
    }

    // optional .mozilla.safebrowsing.Checksum checksum = 8;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->checksum_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
    if (has_threat_entry_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
    if (has_platform_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
    if (has_response_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->response_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(&from));
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  additions_.MergeFrom(from.additions_);
  removals_.MergeFrom(from.removals_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_new_client_state();
      new_client_state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_client_state_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_checksum()->::mozilla::safebrowsing::Checksum::MergeFrom(from.checksum());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      response_type_ = from.response_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
  using std::swap;
  additions_.InternalSwap(&other->additions_);
  removals_.InternalSwap(&other->removals_);
  new_client_state_.Swap(&other->new_client_state_);
  swap(checksum_, other->checksum_);
  swap(threat_type_, other->threat_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
  swap(platform_type_, other->platform_type_);
  swap(response_type_, other->response_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesResponse_ListUpdateResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_type() {
  _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000008u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 3;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_response_type() {
  _has_bits_[0] |= 0x00000020u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000020u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type() {
  response_type_ = 0;
  clear_has_response_type();
}
::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
  return static_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(response_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  assert(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const {
  return additions_.size();
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions() {
  additions_.Clear();
}
const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Get(index);
}
::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Mutable(index);
}
::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return &additions_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_;
}

// repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const {
  return removals_.size();
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals() {
  removals_.Clear();
}
const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Get(index);
}
::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Mutable(index);
}
::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return &removals_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_;
}

// optional bytes new_client_state = 7;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_new_client_state() {
  _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_new_client_state() {
  _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state() {
  new_client_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_new_client_state();
}
const ::std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.GetNoArena();
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const ::std::string& value) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
#if LANG_CXX11
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(::std::string&& value) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
#endif
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const void* value, size_t size) {
  set_has_new_client_state();
  new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state() {
  set_has_new_client_state();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  clear_has_new_client_state();
  return new_client_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(::std::string* new_client_state) {
  if (new_client_state != NULL) {
    set_has_new_client_state();
  } else {
    clear_has_new_client_state();
  }
  new_client_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_client_state);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .mozilla.safebrowsing.Checksum checksum = 8;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_checksum() {
  _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum() {
  if (checksum_ != NULL) checksum_->::mozilla::safebrowsing::Checksum::Clear();
  clear_has_checksum();
}
const ::mozilla::safebrowsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const {
  const ::mozilla::safebrowsing::Checksum* p = checksum_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Checksum*>(
      &::mozilla::safebrowsing::_Checksum_default_instance_);
}
::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == NULL) {
    checksum_ = new ::mozilla::safebrowsing::Checksum;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return checksum_;
}
::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  clear_has_checksum();
  ::mozilla::safebrowsing::Checksum* temp = checksum_;
  checksum_ = NULL;
  return temp;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::mozilla::safebrowsing::Checksum* checksum) {
  delete checksum_;
  checksum_ = checksum;
  if (checksum) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesResponse::kListUpdateResponsesFieldNumber;
const int FetchThreatListUpdatesResponse::kMinimumWaitDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      list_update_responses_(from.list_update_responses_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}

void FetchThreatListUpdatesResponse::SharedCtor() {
  _cached_size_ = 0;
  minimum_wait_duration_ = NULL;
}

FetchThreatListUpdatesResponse::~FetchThreatListUpdatesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  SharedDtor();
}

void FetchThreatListUpdatesResponse::SharedDtor() {
  if (this != internal_default_instance()) delete minimum_wait_duration_;
}

void FetchThreatListUpdatesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesResponse& FetchThreatListUpdatesResponse::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FetchThreatListUpdatesResponse* FetchThreatListUpdatesResponse::New(::google::protobuf::Arena* arena) const {
  FetchThreatListUpdatesResponse* n = new FetchThreatListUpdatesResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FetchThreatListUpdatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_responses_.Clear();
  if (has_minimum_wait_duration()) {
    GOOGLE_DCHECK(minimum_wait_duration_ != NULL);
    minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FetchThreatListUpdatesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list_update_responses()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_minimum_wait_duration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  return false;
#undef DO_
}

void FetchThreatListUpdatesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_update_responses_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->list_update_responses(static_cast<int>(i)), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->minimum_wait_duration_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}

size_t FetchThreatListUpdatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->list_update_responses_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->list_update_responses(static_cast<int>(i)));
    }
  }

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (has_minimum_wait_duration()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->minimum_wait_duration_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchThreatListUpdatesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesResponse*>(&from));
}

void FetchThreatListUpdatesResponse::MergeFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_responses_.MergeFrom(from.list_update_responses_);
  if (from.has_minimum_wait_duration()) {
    mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from.minimum_wait_duration());
  }
}

void FetchThreatListUpdatesResponse::CopyFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse::Swap(FetchThreatListUpdatesResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FetchThreatListUpdatesResponse::InternalSwap(FetchThreatListUpdatesResponse* other) {
  using std::swap;
  list_update_responses_.InternalSwap(&other->list_update_responses_);
  swap(minimum_wait_duration_, other->minimum_wait_duration_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesResponse

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
int FetchThreatListUpdatesResponse::list_update_responses_size() const {
  return list_update_responses_.size();
}
void FetchThreatListUpdatesResponse::clear_list_update_responses() {
  list_update_responses_.Clear();
}
const ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Get(index);
}
::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Mutable(index);
}
::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
FetchThreatListUpdatesResponse::mutable_list_update_responses() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return &list_update_responses_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
FetchThreatListUpdatesResponse::list_update_responses() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
const ::mozilla::safebrowsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const {
  const ::mozilla::safebrowsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindFullHashesRequest::kClientFieldNumber;
const int FindFullHashesRequest::kClientStatesFieldNumber;
const int FindFullHashesRequest::kThreatInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindFullHashesRequest::FindFullHashesRequest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindFullHashesRequest)
}
FindFullHashesRequest::FindFullHashesRequest(const FindFullHashesRequest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      client_states_(from.client_states_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = NULL;
  }
  if (from.has_threat_info()) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesRequest)
}

void FindFullHashesRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindFullHashesRequest::~FindFullHashesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesRequest)
  SharedDtor();
}

void FindFullHashesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindFullHashesRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindFullHashesRequest& FindFullHashesRequest::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FindFullHashesRequest* FindFullHashesRequest::New(::google::protobuf::Arena* arena) const {
  FindFullHashesRequest* n = new FindFullHashesRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindFullHashesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_states_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != NULL);
      client_->::mozilla::safebrowsing::ClientInfo::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != NULL);
      threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FindFullHashesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FindFullHashesRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes client_states = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_client_states()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_threat_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FindFullHashesRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FindFullHashesRequest)
  return false;
#undef DO_
}

void FindFullHashesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FindFullHashesRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->client_, output);
  }

  // repeated bytes client_states = 2;
  for (int i = 0, n = this->client_states_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->client_states(i), output);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->threat_info_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FindFullHashesRequest)
}

size_t FindFullHashesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesRequest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated bytes client_states = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->client_states_size());
  for (int i = 0, n = this->client_states_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->client_states(i));
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
    if (has_threat_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->threat_info_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindFullHashesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindFullHashesRequest*>(&from));
}

void FindFullHashesRequest::MergeFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  client_states_.MergeFrom(from.client_states_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from.client());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(from.threat_info());
    }
  }
}

void FindFullHashesRequest::CopyFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesRequest::IsInitialized() const {
  return true;
}

void FindFullHashesRequest::Swap(FindFullHashesRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindFullHashesRequest::InternalSwap(FindFullHashesRequest* other) {
  using std::swap;
  client_states_.InternalSwap(&other->client_states_);
  swap(client_, other->client_);
  swap(threat_info_, other->threat_info_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FindFullHashesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindFullHashesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
bool FindFullHashesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindFullHashesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
void FindFullHashesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindFullHashesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
const ::mozilla::safebrowsing::ClientInfo& FindFullHashesRequest::client() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) {
    client_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client)
  return client_;
}
::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::release_client() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesRequest.client)
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
void FindFullHashesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
int FindFullHashesRequest::client_states_size() const {
  return client_states_.size();
}
void FindFullHashesRequest::clear_client_states() {
  client_states_.Clear();
}
const ::std::string& FindFullHashesRequest::client_states(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Get(index);
}
::std::string* FindFullHashesRequest::mutable_client_states(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Mutable(index);
}
void FindFullHashesRequest::set_client_states(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void FindFullHashesRequest::set_client_states(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(std::move(value));
}
#endif
void FindFullHashesRequest::set_client_states(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size) {
  client_states_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
::std::string* FindFullHashesRequest::add_client_states() {
  // @@protoc_insertion_point(field_add_mutable:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Add();
}
void FindFullHashesRequest::add_client_states(const ::std::string& value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
#if LANG_CXX11
void FindFullHashesRequest::add_client_states(::std::string&& value) {
  client_states_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
#endif
void FindFullHashesRequest::add_client_states(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
void FindFullHashesRequest::add_client_states(const void* value, size_t size) {
  client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindFullHashesRequest::client_states() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
FindFullHashesRequest::mutable_client_states() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return &client_states_;
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
bool FindFullHashesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindFullHashesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000002u;
}
void FindFullHashesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
}
void FindFullHashesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
const ::mozilla::safebrowsing::ThreatInfo& FindFullHashesRequest::threat_info() const {
  const ::mozilla::safebrowsing::ThreatInfo* p = threat_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatInfo*>(
      &::mozilla::safebrowsing::_ThreatInfo_default_instance_);
}
::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  return threat_info_;
}
::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::release_threat_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
void FindFullHashesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindFullHashesResponse::kMatchesFieldNumber;
const int FindFullHashesResponse::kMinimumWaitDurationFieldNumber;
const int FindFullHashesResponse::kNegativeCacheDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindFullHashesResponse::FindFullHashesResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindFullHashesResponse)
}
FindFullHashesResponse::FindFullHashesResponse(const FindFullHashesResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = NULL;
  }
  if (from.has_negative_cache_duration()) {
    negative_cache_duration_ = new ::mozilla::safebrowsing::Duration(*from.negative_cache_duration_);
  } else {
    negative_cache_duration_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesResponse)
}

void FindFullHashesResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&minimum_wait_duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&negative_cache_duration_) -
      reinterpret_cast<char*>(&minimum_wait_duration_)) + sizeof(negative_cache_duration_));
}

FindFullHashesResponse::~FindFullHashesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesResponse)
  SharedDtor();
}

void FindFullHashesResponse::SharedDtor() {
  if (this != internal_default_instance()) delete minimum_wait_duration_;
  if (this != internal_default_instance()) delete negative_cache_duration_;
}

void FindFullHashesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindFullHashesResponse& FindFullHashesResponse::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

FindFullHashesResponse* FindFullHashesResponse::New(::google::protobuf::Arena* arena) const {
  FindFullHashesResponse* n = new FindFullHashesResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindFullHashesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(minimum_wait_duration_ != NULL);
      minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(negative_cache_duration_ != NULL);
      negative_cache_duration_->::mozilla::safebrowsing::Duration::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FindFullHashesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.FindFullHashesResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_matches()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_minimum_wait_duration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_negative_cache_duration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.FindFullHashesResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.FindFullHashesResponse)
  return false;
#undef DO_
}

void FindFullHashesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.FindFullHashesResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->matches_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->matches(static_cast<int>(i)), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->minimum_wait_duration_, output);
  }

  // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->negative_cache_duration_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.FindFullHashesResponse)
}

size_t FindFullHashesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->matches_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matches(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
    if (has_minimum_wait_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->minimum_wait_duration_);
    }

    // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
    if (has_negative_cache_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->negative_cache_duration_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindFullHashesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindFullHashesResponse*>(&from));
}

void FindFullHashesResponse::MergeFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from.minimum_wait_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_negative_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from.negative_cache_duration());
    }
  }
}

void FindFullHashesResponse::CopyFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesResponse::IsInitialized() const {
  return true;
}

void FindFullHashesResponse::Swap(FindFullHashesResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindFullHashesResponse::InternalSwap(FindFullHashesResponse* other) {
  using std::swap;
  matches_.InternalSwap(&other->matches_);
  swap(minimum_wait_duration_, other->minimum_wait_duration_);
  swap(negative_cache_duration_, other->negative_cache_duration_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string FindFullHashesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindFullHashesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
int FindFullHashesResponse::matches_size() const {
  return matches_.size();
}
void FindFullHashesResponse::clear_matches() {
  matches_.Clear();
}
const ::mozilla::safebrowsing::ThreatMatch& FindFullHashesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Get(index);
}
::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Mutable(index);
}
::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindFullHashesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return &matches_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindFullHashesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
bool FindFullHashesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindFullHashesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
}
void FindFullHashesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindFullHashesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::minimum_wait_duration() const {
  const ::mozilla::safebrowsing::Duration* p = minimum_wait_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
void FindFullHashesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
bool FindFullHashesResponse::has_negative_cache_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindFullHashesResponse::set_has_negative_cache_duration() {
  _has_bits_[0] |= 0x00000002u;
}
void FindFullHashesResponse::clear_has_negative_cache_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
void FindFullHashesResponse::clear_negative_cache_duration() {
  if (negative_cache_duration_ != NULL) negative_cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_negative_cache_duration();
}
const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::negative_cache_duration() const {
  const ::mozilla::safebrowsing::Duration* p = negative_cache_duration_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::Duration*>(
      &::mozilla::safebrowsing::_Duration_default_instance_);
}
::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration() {
  set_has_negative_cache_duration();
  if (negative_cache_duration_ == NULL) {
    negative_cache_duration_ = new ::mozilla::safebrowsing::Duration;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  return negative_cache_duration_;
}
::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_negative_cache_duration() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  clear_has_negative_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = NULL;
  return temp;
}
void FindFullHashesResponse::set_allocated_negative_cache_duration(::mozilla::safebrowsing::Duration* negative_cache_duration) {
  delete negative_cache_duration_;
  negative_cache_duration_ = negative_cache_duration;
  if (negative_cache_duration) {
    set_has_negative_cache_duration();
  } else {
    clear_has_negative_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatHit_ThreatSource::kUrlFieldNumber;
const int ThreatHit_ThreatSource::kTypeFieldNumber;
const int ThreatHit_ThreatSource::kRemoteIpFieldNumber;
const int ThreatHit_ThreatSource::kReferrerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatHit_ThreatSource::ThreatHit_ThreatSource()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}
ThreatHit_ThreatSource::ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_url()) {
    url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
  }
  remote_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_remote_ip()) {
    remote_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.remote_ip_);
  }
  referrer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_referrer()) {
    referrer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referrer_);
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}

void ThreatHit_ThreatSource::SharedCtor() {
  _cached_size_ = 0;
  url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remote_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referrer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
}

ThreatHit_ThreatSource::~ThreatHit_ThreatSource() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
  SharedDtor();
}

void ThreatHit_ThreatSource::SharedDtor() {
  url_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remote_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  referrer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ThreatHit_ThreatSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatHit_ThreatSource& ThreatHit_ThreatSource::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatHit_ThreatSource* ThreatHit_ThreatSource::New(::google::protobuf::Arena* arena) const {
  ThreatHit_ThreatSource* n = new ThreatHit_ThreatSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatHit_ThreatSource::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!url_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*url_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!remote_ip_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*remote_ip_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!referrer_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*referrer_.UnsafeRawStringPointer())->clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatHit_ThreatSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string url = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(value)) {
            set_type(static_cast< ::mozilla::safebrowsing::ThreatHit_ThreatSourceType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string remote_ip = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remote_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string referrer = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_referrer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatHit.ThreatSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatHit.ThreatSource)
  return false;
#undef DO_
}

void ThreatHit_ThreatSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->url(), output);
  }

  // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional string remote_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->remote_ip(), output);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->referrer(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatHit.ThreatSource)
}

size_t ThreatHit_ThreatSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 15u) {
    // optional string url = 1;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }

    // optional string remote_ip = 3;
    if (has_remote_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remote_ip());
    }

    // optional string referrer = 4;
    if (has_referrer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->referrer());
    }

    // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatHit_ThreatSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatHit_ThreatSource*>(&from));
}

void ThreatHit_ThreatSource::MergeFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_url();
      url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_remote_ip();
      remote_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.remote_ip_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_referrer();
      referrer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referrer_);
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatHit_ThreatSource::CopyFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_ThreatSource::IsInitialized() const {
  return true;
}

void ThreatHit_ThreatSource::Swap(ThreatHit_ThreatSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatHit_ThreatSource::InternalSwap(ThreatHit_ThreatSource* other) {
  using std::swap;
  url_.Swap(&other->url_);
  remote_ip_.Swap(&other->remote_ip_);
  referrer_.Swap(&other->referrer_);
  swap(type_, other->type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatHit_ThreatSource::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.ThreatSource";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatHit_ThreatSource

// optional string url = 1;
bool ThreatHit_ThreatSource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatHit_ThreatSource::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatHit_ThreatSource::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatHit_ThreatSource::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
const ::std::string& ThreatHit_ThreatSource::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return url_.GetNoArena();
}
void ThreatHit_ThreatSource::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
#if LANG_CXX11
void ThreatHit_ThreatSource::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
#endif
void ThreatHit_ThreatSource::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
void ThreatHit_ThreatSource::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
::std::string* ThreatHit_ThreatSource::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_url() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}

// optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
bool ThreatHit_ThreatSource::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatHit_ThreatSource::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
void ThreatHit_ThreatSource::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void ThreatHit_ThreatSource::clear_type() {
  type_ = 0;
  clear_has_type();
}
::mozilla::safebrowsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
  return static_cast< ::mozilla::safebrowsing::ThreatHit_ThreatSourceType >(type_);
}
void ThreatHit_ThreatSource::set_type(::mozilla::safebrowsing::ThreatHit_ThreatSourceType value) {
  assert(::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
bool ThreatHit_ThreatSource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatHit_ThreatSource::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatHit_ThreatSource::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatHit_ThreatSource::clear_remote_ip() {
  remote_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remote_ip();
}
const ::std::string& ThreatHit_ThreatSource::remote_ip() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.GetNoArena();
}
void ThreatHit_ThreatSource::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
#if LANG_CXX11
void ThreatHit_ThreatSource::set_remote_ip(::std::string&& value) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
#endif
void ThreatHit_ThreatSource::set_remote_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
void ThreatHit_ThreatSource::set_remote_ip(const char* value, size_t size) {
  set_has_remote_ip();
  remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
::std::string* ThreatHit_ThreatSource::mutable_remote_ip() {
  set_has_remote_ip();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_remote_ip() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  clear_has_remote_ip();
  return remote_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_remote_ip(::std::string* remote_ip) {
  if (remote_ip != NULL) {
    set_has_remote_ip();
  } else {
    clear_has_remote_ip();
  }
  remote_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
bool ThreatHit_ThreatSource::has_referrer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatHit_ThreatSource::set_has_referrer() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreatHit_ThreatSource::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreatHit_ThreatSource::clear_referrer() {
  referrer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_referrer();
}
const ::std::string& ThreatHit_ThreatSource::referrer() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return referrer_.GetNoArena();
}
void ThreatHit_ThreatSource::set_referrer(const ::std::string& value) {
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
#if LANG_CXX11
void ThreatHit_ThreatSource::set_referrer(::std::string&& value) {
  set_has_referrer();
  referrer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
#endif
void ThreatHit_ThreatSource::set_referrer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
void ThreatHit_ThreatSource::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
::std::string* ThreatHit_ThreatSource::mutable_referrer() {
  set_has_referrer();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return referrer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_referrer() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  clear_has_referrer();
  return referrer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_referrer(::std::string* referrer) {
  if (referrer != NULL) {
    set_has_referrer();
  } else {
    clear_has_referrer();
  }
  referrer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referrer);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatHit_UserInfo::kRegionCodeFieldNumber;
const int ThreatHit_UserInfo::kUserIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatHit_UserInfo::ThreatHit_UserInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}
ThreatHit_UserInfo::ThreatHit_UserInfo(const ThreatHit_UserInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  region_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_region_code()) {
    region_code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.region_code_);
  }
  user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_id()) {
    user_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_id_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}

void ThreatHit_UserInfo::SharedCtor() {
  _cached_size_ = 0;
  region_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ThreatHit_UserInfo::~ThreatHit_UserInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.UserInfo)
  SharedDtor();
}

void ThreatHit_UserInfo::SharedDtor() {
  region_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ThreatHit_UserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatHit_UserInfo& ThreatHit_UserInfo::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatHit_UserInfo* ThreatHit_UserInfo::New(::google::protobuf::Arena* arena) const {
  ThreatHit_UserInfo* n = new ThreatHit_UserInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatHit_UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!region_code_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*region_code_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!user_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*user_id_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatHit_UserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string region_code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_region_code()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatHit.UserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatHit.UserInfo)
  return false;
#undef DO_
}

void ThreatHit_UserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string region_code = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->region_code(), output);
  }

  // optional bytes user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->user_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatHit.UserInfo)
}

size_t ThreatHit_UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string region_code = 1;
    if (has_region_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->region_code());
    }

    // optional bytes user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatHit_UserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatHit_UserInfo*>(&from));
}

void ThreatHit_UserInfo::MergeFrom(const ThreatHit_UserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_region_code();
      region_code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.region_code_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_user_id();
      user_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_id_);
    }
  }
}

void ThreatHit_UserInfo::CopyFrom(const ThreatHit_UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_UserInfo::IsInitialized() const {
  return true;
}

void ThreatHit_UserInfo::Swap(ThreatHit_UserInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatHit_UserInfo::InternalSwap(ThreatHit_UserInfo* other) {
  using std::swap;
  region_code_.Swap(&other->region_code_);
  user_id_.Swap(&other->user_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatHit_UserInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.UserInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatHit_UserInfo

// optional string region_code = 1;
bool ThreatHit_UserInfo::has_region_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatHit_UserInfo::set_has_region_code() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatHit_UserInfo::clear_has_region_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatHit_UserInfo::clear_region_code() {
  region_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_region_code();
}
const ::std::string& ThreatHit_UserInfo::region_code() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  return region_code_.GetNoArena();
}
void ThreatHit_UserInfo::set_region_code(const ::std::string& value) {
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
#if LANG_CXX11
void ThreatHit_UserInfo::set_region_code(::std::string&& value) {
  set_has_region_code();
  region_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
#endif
void ThreatHit_UserInfo::set_region_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
void ThreatHit_UserInfo::set_region_code(const char* value, size_t size) {
  set_has_region_code();
  region_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}
::std::string* ThreatHit_UserInfo::mutable_region_code() {
  set_has_region_code();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  return region_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_UserInfo::release_region_code() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
  clear_has_region_code();
  return region_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_UserInfo::set_allocated_region_code(::std::string* region_code) {
  if (region_code != NULL) {
    set_has_region_code();
  } else {
    clear_has_region_code();
  }
  region_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region_code);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.UserInfo.region_code)
}

// optional bytes user_id = 2;
bool ThreatHit_UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatHit_UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatHit_UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatHit_UserInfo::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
const ::std::string& ThreatHit_UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  return user_id_.GetNoArena();
}
void ThreatHit_UserInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
#if LANG_CXX11
void ThreatHit_UserInfo::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
#endif
void ThreatHit_UserInfo::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
void ThreatHit_UserInfo::set_user_id(const void* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}
::std::string* ThreatHit_UserInfo::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_UserInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_UserInfo::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.UserInfo.user_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatHit::kThreatTypeFieldNumber;
const int ThreatHit::kPlatformTypeFieldNumber;
const int ThreatHit::kEntryFieldNumber;
const int ThreatHit::kResourcesFieldNumber;
const int ThreatHit::kClientInfoFieldNumber;
const int ThreatHit::kUserInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatHit::ThreatHit()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit)
}
ThreatHit::ThreatHit(const ThreatHit& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      resources_(from.resources_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_entry()) {
    entry_ = new ::mozilla::safebrowsing::ThreatEntry(*from.entry_);
  } else {
    entry_ = NULL;
  }
  if (from.has_client_info()) {
    client_info_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_info_);
  } else {
    client_info_ = NULL;
  }
  if (from.has_user_info()) {
    user_info_ = new ::mozilla::safebrowsing::ThreatHit_UserInfo(*from.user_info_);
  } else {
    user_info_ = NULL;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit)
}

void ThreatHit::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&entry_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&platform_type_) -
      reinterpret_cast<char*>(&entry_)) + sizeof(platform_type_));
}

ThreatHit::~ThreatHit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit)
  SharedDtor();
}

void ThreatHit::SharedDtor() {
  if (this != internal_default_instance()) delete entry_;
  if (this != internal_default_instance()) delete client_info_;
  if (this != internal_default_instance()) delete user_info_;
}

void ThreatHit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatHit& ThreatHit::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatHit* ThreatHit::New(::google::protobuf::Arena* arena) const {
  ThreatHit* n = new ThreatHit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatHit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resources_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(entry_ != NULL);
      entry_->::mozilla::safebrowsing::ThreatEntry::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_info_ != NULL);
      client_info_->::mozilla::safebrowsing::ClientInfo::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(user_info_ != NULL);
      user_info_->::mozilla::safebrowsing::ThreatHit_UserInfo::Clear();
    }
  }
  if (cached_has_bits & 24u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&platform_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatHit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatHit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            set_threat_type(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            set_platform_type(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entry()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatHit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatHit)
  return false;
#undef DO_
}

void ThreatHit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatHit)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_type(), output);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->platform_type(), output);
  }

  // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->entry_, output);
  }

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->resources_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->resources(static_cast<int>(i)), output);
  }

  // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->client_info_, output);
  }

  // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->user_info_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatHit)
}

size_t ThreatHit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->resources_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->resources(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 31u) {
    // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
    if (has_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->entry_);
    }

    // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
    if (has_client_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_info_);
    }

    // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->user_info_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatHit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatHit*>(&from));
}

void ThreatHit::MergeFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  resources_.MergeFrom(from.resources_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_entry()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(from.entry());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_client_info()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from.client_info());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_user_info()->::mozilla::safebrowsing::ThreatHit_UserInfo::MergeFrom(from.user_info());
    }
    if (cached_has_bits & 0x00000008u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatHit::CopyFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit::IsInitialized() const {
  return true;
}

void ThreatHit::Swap(ThreatHit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatHit::InternalSwap(ThreatHit* other) {
  using std::swap;
  resources_.InternalSwap(&other->resources_);
  swap(entry_, other->entry_);
  swap(client_info_, other->client_info_);
  swap(user_info_, other->user_info_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatHit::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatHit

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
bool ThreatHit::has_threat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatHit::set_has_threat_type() {
  _has_bits_[0] |= 0x00000008u;
}
void ThreatHit::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void ThreatHit::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
::mozilla::safebrowsing::ThreatType ThreatHit::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
void ThreatHit::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
bool ThreatHit::has_platform_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ThreatHit::set_has_platform_type() {
  _has_bits_[0] |= 0x00000010u;
}
void ThreatHit::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void ThreatHit::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
::mozilla::safebrowsing::PlatformType ThreatHit::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
void ThreatHit::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntry entry = 3;
bool ThreatHit::has_entry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatHit::set_has_entry() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatHit::clear_has_entry() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatHit::clear_entry() {
  if (entry_ != NULL) entry_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_entry();
}
const ::mozilla::safebrowsing::ThreatEntry& ThreatHit::entry() const {
  const ::mozilla::safebrowsing::ThreatEntry* p = entry_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.entry)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatEntry*>(
      &::mozilla::safebrowsing::_ThreatEntry_default_instance_);
}
::mozilla::safebrowsing::ThreatEntry* ThreatHit::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) {
    entry_ = new ::mozilla::safebrowsing::ThreatEntry;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.entry)
  return entry_;
}
::mozilla::safebrowsing::ThreatEntry* ThreatHit::release_entry() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.entry)
  clear_has_entry();
  ::mozilla::safebrowsing::ThreatEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
void ThreatHit::set_allocated_entry(::mozilla::safebrowsing::ThreatEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.entry)
}

// repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
int ThreatHit::resources_size() const {
  return resources_.size();
}
void ThreatHit::clear_resources() {
  resources_.Clear();
}
const ::mozilla::safebrowsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Get(index);
}
::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Mutable(index);
}
::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::add_resources() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >*
ThreatHit::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatHit.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >&
ThreatHit::resources() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatHit.resources)
  return resources_;
}

// optional .mozilla.safebrowsing.ClientInfo client_info = 5;
bool ThreatHit::has_client_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatHit::set_has_client_info() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatHit::clear_has_client_info() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatHit::clear_client_info() {
  if (client_info_ != NULL) client_info_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client_info();
}
const ::mozilla::safebrowsing::ClientInfo& ThreatHit::client_info() const {
  const ::mozilla::safebrowsing::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ClientInfo*>(
      &::mozilla::safebrowsing::_ClientInfo_default_instance_);
}
::mozilla::safebrowsing::ClientInfo* ThreatHit::mutable_client_info() {
  set_has_client_info();
  if (client_info_ == NULL) {
    client_info_ = new ::mozilla::safebrowsing::ClientInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.client_info)
  return client_info_;
}
::mozilla::safebrowsing::ClientInfo* ThreatHit::release_client_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.client_info)
  clear_has_client_info();
  ::mozilla::safebrowsing::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
void ThreatHit::set_allocated_client_info(::mozilla::safebrowsing::ClientInfo* client_info) {
  delete client_info_;
  client_info_ = client_info;
  if (client_info) {
    set_has_client_info();
  } else {
    clear_has_client_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.client_info)
}

// optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
bool ThreatHit::has_user_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatHit::set_has_user_info() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreatHit::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreatHit::clear_user_info() {
  if (user_info_ != NULL) user_info_->::mozilla::safebrowsing::ThreatHit_UserInfo::Clear();
  clear_has_user_info();
}
const ::mozilla::safebrowsing::ThreatHit_UserInfo& ThreatHit::user_info() const {
  const ::mozilla::safebrowsing::ThreatHit_UserInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::ThreatHit_UserInfo*>(
      &::mozilla::safebrowsing::_ThreatHit_UserInfo_default_instance_);
}
::mozilla::safebrowsing::ThreatHit_UserInfo* ThreatHit::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    user_info_ = new ::mozilla::safebrowsing::ThreatHit_UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.user_info)
  return user_info_;
}
::mozilla::safebrowsing::ThreatHit_UserInfo* ThreatHit::release_user_info() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatHit.user_info)
  clear_has_user_info();
  ::mozilla::safebrowsing::ThreatHit_UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
void ThreatHit::set_allocated_user_info(::mozilla::safebrowsing::ThreatHit_UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.user_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientInfo::kClientIdFieldNumber;
const int ClientInfo::kClientVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientInfo::ClientInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ClientInfo)
}
ClientInfo::ClientInfo(const ClientInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_id()) {
    client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
  }
  client_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_version()) {
    client_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_version_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ClientInfo)
}

void ClientInfo::SharedCtor() {
  _cached_size_ = 0;
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ClientInfo::~ClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ClientInfo)
  SharedDtor();
}

void ClientInfo::SharedDtor() {
  client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ClientInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientInfo& ClientInfo::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClientInfo* ClientInfo::New(::google::protobuf::Arena* arena) const {
  ClientInfo* n = new ClientInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ClientInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!client_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*client_id_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!client_version_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*client_version_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ClientInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string client_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string client_version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ClientInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ClientInfo)
  return false;
#undef DO_
}

void ClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ClientInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_id(), output);
  }

  // optional string client_version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->client_version(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ClientInfo)
}

size_t ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ClientInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string client_id = 1;
    if (has_client_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_id());
    }

    // optional string client_version = 2;
    if (has_client_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientInfo*>(&from));
}

void ClientInfo::MergeFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_client_id();
      client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_client_version();
      client_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_version_);
    }
  }
}

void ClientInfo::CopyFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientInfo::IsInitialized() const {
  return true;
}

void ClientInfo::Swap(ClientInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientInfo::InternalSwap(ClientInfo* other) {
  using std::swap;
  client_id_.Swap(&other->client_id_);
  client_version_.Swap(&other->client_version_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ClientInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientInfo

// optional string client_id = 1;
bool ClientInfo::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientInfo::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientInfo::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientInfo::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
const ::std::string& ClientInfo::client_id() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_id)
  return client_id_.GetNoArena();
}
void ClientInfo::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_id)
}
#if LANG_CXX11
void ClientInfo::set_client_id(::std::string&& value) {
  set_has_client_id();
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ClientInfo.client_id)
}
#endif
void ClientInfo::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_id)
}
void ClientInfo::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_id)
}
::std::string* ClientInfo::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ClientInfo.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_id)
}

// optional string client_version = 2;
bool ClientInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientInfo::set_has_client_version() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientInfo::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientInfo::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_version();
}
const ::std::string& ClientInfo::client_version() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_version)
  return client_version_.GetNoArena();
}
void ClientInfo::set_client_version(const ::std::string& value) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_version)
}
#if LANG_CXX11
void ClientInfo::set_client_version(::std::string&& value) {
  set_has_client_version();
  client_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ClientInfo.client_version)
}
#endif
void ClientInfo::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_version)
}
void ClientInfo::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_version)
}
::std::string* ClientInfo::mutable_client_version() {
  set_has_client_version();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_version)
  return client_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ClientInfo.client_version)
  clear_has_client_version();
  return client_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_allocated_client_version(::std::string* client_version) {
  if (client_version != NULL) {
    set_has_client_version();
  } else {
    clear_has_client_version();
  }
  client_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChromeClientInfo::kReportingPopulationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChromeClientInfo::ChromeClientInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ChromeClientInfo)
}
ChromeClientInfo::ChromeClientInfo(const ChromeClientInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reporting_population_ = from.reporting_population_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ChromeClientInfo)
}

void ChromeClientInfo::SharedCtor() {
  _cached_size_ = 0;
  reporting_population_ = 0;
}

ChromeClientInfo::~ChromeClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ChromeClientInfo)
  SharedDtor();
}

void ChromeClientInfo::SharedDtor() {
}

void ChromeClientInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChromeClientInfo& ChromeClientInfo::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ChromeClientInfo* ChromeClientInfo::New(::google::protobuf::Arena* arena) const {
  ChromeClientInfo* n = new ChromeClientInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChromeClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ChromeClientInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reporting_population_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ChromeClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ChromeClientInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value)) {
            set_reporting_population(static_cast< ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ChromeClientInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ChromeClientInfo)
  return false;
#undef DO_
}

void ChromeClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ChromeClientInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->reporting_population(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ChromeClientInfo)
}

size_t ChromeClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ChromeClientInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  if (has_reporting_population()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->reporting_population());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChromeClientInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChromeClientInfo*>(&from));
}

void ChromeClientInfo::MergeFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ChromeClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reporting_population()) {
    set_reporting_population(from.reporting_population());
  }
}

void ChromeClientInfo::CopyFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ChromeClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeClientInfo::IsInitialized() const {
  return true;
}

void ChromeClientInfo::Swap(ChromeClientInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChromeClientInfo::InternalSwap(ChromeClientInfo* other) {
  using std::swap;
  swap(reporting_population_, other->reporting_population_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ChromeClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ChromeClientInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeClientInfo

// optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
bool ChromeClientInfo::has_reporting_population() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChromeClientInfo::set_has_reporting_population() {
  _has_bits_[0] |= 0x00000001u;
}
void ChromeClientInfo::clear_has_reporting_population() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChromeClientInfo::clear_reporting_population() {
  reporting_population_ = 0;
  clear_has_reporting_population();
}
::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::reporting_population() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ChromeClientInfo.reporting_population)
  return static_cast< ::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation >(reporting_population_);
}
void ChromeClientInfo::set_reporting_population(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  assert(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value));
  set_has_reporting_population();
  reporting_population_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ChromeClientInfo.reporting_population)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Checksum::kSha256FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Checksum::Checksum()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.Checksum)
}
Checksum::Checksum(const Checksum& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sha256_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_sha256()) {
    sha256_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sha256_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Checksum)
}

void Checksum::SharedCtor() {
  _cached_size_ = 0;
  sha256_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Checksum::~Checksum() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Checksum)
  SharedDtor();
}

void Checksum::SharedDtor() {
  sha256_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Checksum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Checksum& Checksum::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

Checksum* Checksum::New(::google::protobuf::Arena* arena) const {
  Checksum* n = new Checksum;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Checksum::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Checksum)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_sha256()) {
    GOOGLE_DCHECK(!sha256_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*sha256_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Checksum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.Checksum)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes sha256 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sha256()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.Checksum)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.Checksum)
  return false;
#undef DO_
}

void Checksum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.Checksum)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes sha256 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->sha256(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.Checksum)
}

size_t Checksum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Checksum)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // optional bytes sha256 = 1;
  if (has_sha256()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->sha256());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Checksum::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Checksum*>(&from));
}

void Checksum::MergeFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Checksum)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_sha256()) {
    set_has_sha256();
    sha256_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sha256_);
  }
}

void Checksum::CopyFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Checksum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Checksum::IsInitialized() const {
  return true;
}

void Checksum::Swap(Checksum* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Checksum::InternalSwap(Checksum* other) {
  using std::swap;
  sha256_.Swap(&other->sha256_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Checksum::GetTypeName() const {
  return "mozilla.safebrowsing.Checksum";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Checksum

// optional bytes sha256 = 1;
bool Checksum::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Checksum::set_has_sha256() {
  _has_bits_[0] |= 0x00000001u;
}
void Checksum::clear_has_sha256() {
  _has_bits_[0] &= ~0x00000001u;
}
void Checksum::clear_sha256() {
  sha256_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sha256();
}
const ::std::string& Checksum::sha256() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Checksum.sha256)
  return sha256_.GetNoArena();
}
void Checksum::set_sha256(const ::std::string& value) {
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Checksum.sha256)
}
#if LANG_CXX11
void Checksum::set_sha256(::std::string&& value) {
  set_has_sha256();
  sha256_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.Checksum.sha256)
}
#endif
void Checksum::set_sha256(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.Checksum.sha256)
}
void Checksum::set_sha256(const void* value, size_t size) {
  set_has_sha256();
  sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.Checksum.sha256)
}
::std::string* Checksum::mutable_sha256() {
  set_has_sha256();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.Checksum.sha256)
  return sha256_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Checksum::release_sha256() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.Checksum.sha256)
  clear_has_sha256();
  return sha256_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Checksum::set_allocated_sha256(::std::string* sha256) {
  if (sha256 != NULL) {
    set_has_sha256();
  } else {
    clear_has_sha256();
  }
  sha256_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.Checksum.sha256)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntry::kHashFieldNumber;
const int ThreatEntry::kUrlFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntry::ThreatEntry()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntry)
}
ThreatEntry::ThreatEntry(const ThreatEntry& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_url()) {
    url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntry)
}

void ThreatEntry::SharedCtor() {
  _cached_size_ = 0;
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ThreatEntry::~ThreatEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntry)
  SharedDtor();
}

void ThreatEntry::SharedDtor() {
  hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  url_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ThreatEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntry& ThreatEntry::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatEntry* ThreatEntry::New(::google::protobuf::Arena* arena) const {
  ThreatEntry* n = new ThreatEntry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!hash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hash_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!url_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*url_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes hash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string url = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatEntry)
  return false;
#undef DO_
}

void ThreatEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatEntry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->hash(), output);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->url(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatEntry)
}

size_t ThreatEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntry)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional string url = 2;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatEntry*>(&from));
}

void ThreatEntry::MergeFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_hash();
      hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_url();
      url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
    }
  }
}

void ThreatEntry::CopyFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntry::IsInitialized() const {
  return true;
}

void ThreatEntry::Swap(ThreatEntry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatEntry::InternalSwap(ThreatEntry* other) {
  using std::swap;
  hash_.Swap(&other->hash_);
  url_.Swap(&other->url_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntry";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntry

// optional bytes hash = 1;
bool ThreatEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntry::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatEntry::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntry::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
const ::std::string& ThreatEntry::hash() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.hash)
  return hash_.GetNoArena();
}
void ThreatEntry::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.hash)
}
#if LANG_CXX11
void ThreatEntry::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntry.hash)
}
#endif
void ThreatEntry::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.hash)
}
void ThreatEntry::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.hash)
}
::std::string* ThreatEntry::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntry::release_hash() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntry.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.hash)
}

// optional string url = 2;
bool ThreatEntry::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntry::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatEntry::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntry::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
const ::std::string& ThreatEntry::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.url)
  return url_.GetNoArena();
}
void ThreatEntry::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.url)
}
#if LANG_CXX11
void ThreatEntry::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntry.url)
}
#endif
void ThreatEntry::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.url)
}
void ThreatEntry::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.url)
}
::std::string* ThreatEntry::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntry::release_url() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntry.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.url)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntrySet::kCompressionTypeFieldNumber;
const int ThreatEntrySet::kRawHashesFieldNumber;
const int ThreatEntrySet::kRawIndicesFieldNumber;
const int ThreatEntrySet::kRiceHashesFieldNumber;
const int ThreatEntrySet::kRiceIndicesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntrySet::ThreatEntrySet()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntrySet)
}
ThreatEntrySet::ThreatEntrySet(const ThreatEntrySet& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_raw_hashes()) {
    raw_hashes_ = new ::mozilla::safebrowsing::RawHashes(*from.raw_hashes_);
  } else {
    raw_hashes_ = NULL;
  }
  if (from.has_raw_indices()) {
    raw_indices_ = new ::mozilla::safebrowsing::RawIndices(*from.raw_indices_);
  } else {
    raw_indices_ = NULL;
  }
  if (from.has_rice_hashes()) {
    rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from.rice_hashes_);
  } else {
    rice_hashes_ = NULL;
  }
  if (from.has_rice_indices()) {
    rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from.rice_indices_);
  } else {
    rice_indices_ = NULL;
  }
  compression_type_ = from.compression_type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntrySet)
}

void ThreatEntrySet::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&raw_hashes_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&compression_type_) -
      reinterpret_cast<char*>(&raw_hashes_)) + sizeof(compression_type_));
}

ThreatEntrySet::~ThreatEntrySet() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntrySet)
  SharedDtor();
}

void ThreatEntrySet::SharedDtor() {
  if (this != internal_default_instance()) delete raw_hashes_;
  if (this != internal_default_instance()) delete raw_indices_;
  if (this != internal_default_instance()) delete rice_hashes_;
  if (this != internal_default_instance()) delete rice_indices_;
}

void ThreatEntrySet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntrySet& ThreatEntrySet::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatEntrySet* ThreatEntrySet::New(::google::protobuf::Arena* arena) const {
  ThreatEntrySet* n = new ThreatEntrySet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatEntrySet::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntrySet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(raw_hashes_ != NULL);
      raw_hashes_->::mozilla::safebrowsing::RawHashes::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(raw_indices_ != NULL);
      raw_indices_->::mozilla::safebrowsing::RawIndices::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rice_hashes_ != NULL);
      rice_hashes_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rice_indices_ != NULL);
      rice_indices_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
    }
  }
  compression_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatEntrySet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatEntrySet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::CompressionType_IsValid(value)) {
            set_compression_type(static_cast< ::mozilla::safebrowsing::CompressionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_raw_hashes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_raw_indices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rice_hashes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rice_indices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatEntrySet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatEntrySet)
  return false;
#undef DO_
}

void ThreatEntrySet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatEntrySet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->compression_type(), output);
  }

  // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->raw_hashes_, output);
  }

  // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->raw_indices_, output);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->rice_hashes_, output);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->rice_indices_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatEntrySet)
}

size_t ThreatEntrySet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntrySet)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
    if (has_raw_hashes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->raw_hashes_);
    }

    // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
    if (has_raw_indices()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->raw_indices_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
    if (has_rice_hashes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rice_hashes_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
    if (has_rice_indices()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rice_indices_);
    }

    // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
    if (has_compression_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compression_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatEntrySet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatEntrySet*>(&from));
}

void ThreatEntrySet::MergeFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntrySet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_raw_hashes()->::mozilla::safebrowsing::RawHashes::MergeFrom(from.raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_raw_indices()->::mozilla::safebrowsing::RawIndices::MergeFrom(from.raw_indices());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_rice_hashes()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(from.rice_hashes());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_rice_indices()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(from.rice_indices());
    }
    if (cached_has_bits & 0x00000010u) {
      compression_type_ = from.compression_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatEntrySet::CopyFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntrySet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntrySet::IsInitialized() const {
  return true;
}

void ThreatEntrySet::Swap(ThreatEntrySet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatEntrySet::InternalSwap(ThreatEntrySet* other) {
  using std::swap;
  swap(raw_hashes_, other->raw_hashes_);
  swap(raw_indices_, other->raw_indices_);
  swap(rice_hashes_, other->rice_hashes_);
  swap(rice_indices_, other->rice_indices_);
  swap(compression_type_, other->compression_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntrySet::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntrySet";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntrySet

// optional .mozilla.safebrowsing.CompressionType compression_type = 1;
bool ThreatEntrySet::has_compression_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ThreatEntrySet::set_has_compression_type() {
  _has_bits_[0] |= 0x00000010u;
}
void ThreatEntrySet::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void ThreatEntrySet::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
::mozilla::safebrowsing::CompressionType ThreatEntrySet::compression_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.compression_type)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(compression_type_);
}
void ThreatEntrySet::set_compression_type(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntrySet.compression_type)
}

// optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
bool ThreatEntrySet::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntrySet::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatEntrySet::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntrySet::clear_raw_hashes() {
  if (raw_hashes_ != NULL) raw_hashes_->::mozilla::safebrowsing::RawHashes::Clear();
  clear_has_raw_hashes();
}
const ::mozilla::safebrowsing::RawHashes& ThreatEntrySet::raw_hashes() const {
  const ::mozilla::safebrowsing::RawHashes* p = raw_hashes_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RawHashes*>(
      &::mozilla::safebrowsing::_RawHashes_default_instance_);
}
::mozilla::safebrowsing::RawHashes* ThreatEntrySet::mutable_raw_hashes() {
  set_has_raw_hashes();
  if (raw_hashes_ == NULL) {
    raw_hashes_ = new ::mozilla::safebrowsing::RawHashes;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  return raw_hashes_;
}
::mozilla::safebrowsing::RawHashes* ThreatEntrySet::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  clear_has_raw_hashes();
  ::mozilla::safebrowsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = NULL;
  return temp;
}
void ThreatEntrySet::set_allocated_raw_hashes(::mozilla::safebrowsing::RawHashes* raw_hashes) {
  delete raw_hashes_;
  raw_hashes_ = raw_hashes;
  if (raw_hashes) {
    set_has_raw_hashes();
  } else {
    clear_has_raw_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
}

// optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
bool ThreatEntrySet::has_raw_indices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntrySet::set_has_raw_indices() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatEntrySet::clear_has_raw_indices() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntrySet::clear_raw_indices() {
  if (raw_indices_ != NULL) raw_indices_->::mozilla::safebrowsing::RawIndices::Clear();
  clear_has_raw_indices();
}
const ::mozilla::safebrowsing::RawIndices& ThreatEntrySet::raw_indices() const {
  const ::mozilla::safebrowsing::RawIndices* p = raw_indices_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RawIndices*>(
      &::mozilla::safebrowsing::_RawIndices_default_instance_);
}
::mozilla::safebrowsing::RawIndices* ThreatEntrySet::mutable_raw_indices() {
  set_has_raw_indices();
  if (raw_indices_ == NULL) {
    raw_indices_ = new ::mozilla::safebrowsing::RawIndices;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  return raw_indices_;
}
::mozilla::safebrowsing::RawIndices* ThreatEntrySet::release_raw_indices() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  clear_has_raw_indices();
  ::mozilla::safebrowsing::RawIndices* temp = raw_indices_;
  raw_indices_ = NULL;
  return temp;
}
void ThreatEntrySet::set_allocated_raw_indices(::mozilla::safebrowsing::RawIndices* raw_indices) {
  delete raw_indices_;
  raw_indices_ = raw_indices;
  if (raw_indices) {
    set_has_raw_indices();
  } else {
    clear_has_raw_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
bool ThreatEntrySet::has_rice_hashes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatEntrySet::set_has_rice_hashes() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreatEntrySet::clear_has_rice_hashes() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreatEntrySet::clear_rice_hashes() {
  if (rice_hashes_ != NULL) rice_hashes_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_hashes();
}
const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const {
  const ::mozilla::safebrowsing::RiceDeltaEncoding* p = rice_hashes_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      &::mozilla::safebrowsing::_RiceDeltaEncoding_default_instance_);
}
::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes() {
  set_has_rice_hashes();
  if (rice_hashes_ == NULL) {
    rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  return rice_hashes_;
}
::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  clear_has_rice_hashes();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = NULL;
  return temp;
}
void ThreatEntrySet::set_allocated_rice_hashes(::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes) {
  delete rice_hashes_;
  rice_hashes_ = rice_hashes;
  if (rice_hashes) {
    set_has_rice_hashes();
  } else {
    clear_has_rice_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
bool ThreatEntrySet::has_rice_indices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatEntrySet::set_has_rice_indices() {
  _has_bits_[0] |= 0x00000008u;
}
void ThreatEntrySet::clear_has_rice_indices() {
  _has_bits_[0] &= ~0x00000008u;
}
void ThreatEntrySet::clear_rice_indices() {
  if (rice_indices_ != NULL) rice_indices_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_indices();
}
const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const {
  const ::mozilla::safebrowsing::RiceDeltaEncoding* p = rice_indices_;
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  return p != NULL ? *p : *reinterpret_cast<const ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      &::mozilla::safebrowsing::_RiceDeltaEncoding_default_instance_);
}
::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices() {
  set_has_rice_indices();
  if (rice_indices_ == NULL) {
    rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  return rice_indices_;
}
::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  clear_has_rice_indices();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = NULL;
  return temp;
}
void ThreatEntrySet::set_allocated_rice_indices(::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices) {
  delete rice_indices_;
  rice_indices_ = rice_indices;
  if (rice_indices) {
    set_has_rice_indices();
  } else {
    clear_has_rice_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RawIndices::kIndicesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RawIndices::RawIndices()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RawIndices)
}
RawIndices::RawIndices(const RawIndices& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      indices_(from.indices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawIndices)
}

void RawIndices::SharedCtor() {
  _cached_size_ = 0;
}

RawIndices::~RawIndices() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawIndices)
  SharedDtor();
}

void RawIndices::SharedDtor() {
}

void RawIndices::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawIndices& RawIndices::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

RawIndices* RawIndices::New(::google::protobuf::Arena* arena) const {
  RawIndices* n = new RawIndices;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RawIndices::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawIndices)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  indices_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RawIndices::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.RawIndices)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 indices = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8u, input, this->mutable_indices())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_indices())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.RawIndices)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.RawIndices)
  return false;
#undef DO_
}

void RawIndices::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.RawIndices)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  for (int i = 0, n = this->indices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->indices(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.RawIndices)
}

size_t RawIndices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawIndices)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated int32 indices = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->indices_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->indices_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawIndices::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RawIndices*>(&from));
}

void RawIndices::MergeFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawIndices)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  indices_.MergeFrom(from.indices_);
}

void RawIndices::CopyFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawIndices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawIndices::IsInitialized() const {
  return true;
}

void RawIndices::Swap(RawIndices* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RawIndices::InternalSwap(RawIndices* other) {
  using std::swap;
  indices_.InternalSwap(&other->indices_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RawIndices::GetTypeName() const {
  return "mozilla.safebrowsing.RawIndices";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RawIndices

// repeated int32 indices = 1;
int RawIndices::indices_size() const {
  return indices_.size();
}
void RawIndices::clear_indices() {
  indices_.Clear();
}
::google::protobuf::int32 RawIndices::indices(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawIndices.indices)
  return indices_.Get(index);
}
void RawIndices::set_indices(int index, ::google::protobuf::int32 value) {
  indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawIndices.indices)
}
void RawIndices::add_indices(::google::protobuf::int32 value) {
  indices_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.RawIndices.indices)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RawIndices::indices() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.RawIndices.indices)
  return indices_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RawIndices::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.RawIndices.indices)
  return &indices_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RawHashes::kPrefixSizeFieldNumber;
const int RawHashes::kRawHashesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RawHashes::RawHashes()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RawHashes)
}
RawHashes::RawHashes(const RawHashes& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  raw_hashes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_raw_hashes()) {
    raw_hashes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.raw_hashes_);
  }
  prefix_size_ = from.prefix_size_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawHashes)
}

void RawHashes::SharedCtor() {
  _cached_size_ = 0;
  raw_hashes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_size_ = 0;
}

RawHashes::~RawHashes() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawHashes)
  SharedDtor();
}

void RawHashes::SharedDtor() {
  raw_hashes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RawHashes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawHashes& RawHashes::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

RawHashes* RawHashes::New(::google::protobuf::Arena* arena) const {
  RawHashes* n = new RawHashes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RawHashes::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawHashes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_raw_hashes()) {
    GOOGLE_DCHECK(!raw_hashes_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*raw_hashes_.UnsafeRawStringPointer())->clear();
  }
  prefix_size_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RawHashes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.RawHashes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 prefix_size = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_prefix_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &prefix_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes raw_hashes = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_raw_hashes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.RawHashes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.RawHashes)
  return false;
#undef DO_
}

void RawHashes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.RawHashes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 prefix_size = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->prefix_size(), output);
  }

  // optional bytes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->raw_hashes(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.RawHashes)
}

size_t RawHashes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawHashes)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes raw_hashes = 2;
    if (has_raw_hashes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->raw_hashes());
    }

    // optional int32 prefix_size = 1;
    if (has_prefix_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->prefix_size());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawHashes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RawHashes*>(&from));
}

void RawHashes::MergeFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawHashes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_raw_hashes();
      raw_hashes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.raw_hashes_);
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_size_ = from.prefix_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RawHashes::CopyFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawHashes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawHashes::IsInitialized() const {
  return true;
}

void RawHashes::Swap(RawHashes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RawHashes::InternalSwap(RawHashes* other) {
  using std::swap;
  raw_hashes_.Swap(&other->raw_hashes_);
  swap(prefix_size_, other->prefix_size_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RawHashes::GetTypeName() const {
  return "mozilla.safebrowsing.RawHashes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RawHashes

// optional int32 prefix_size = 1;
bool RawHashes::has_prefix_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RawHashes::set_has_prefix_size() {
  _has_bits_[0] |= 0x00000002u;
}
void RawHashes::clear_has_prefix_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void RawHashes::clear_prefix_size() {
  prefix_size_ = 0;
  clear_has_prefix_size();
}
::google::protobuf::int32 RawHashes::prefix_size() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.prefix_size)
  return prefix_size_;
}
void RawHashes::set_prefix_size(::google::protobuf::int32 value) {
  set_has_prefix_size();
  prefix_size_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
bool RawHashes::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RawHashes::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
}
void RawHashes::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000001u;
}
void RawHashes::clear_raw_hashes() {
  raw_hashes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_raw_hashes();
}
const ::std::string& RawHashes::raw_hashes() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.raw_hashes)
  return raw_hashes_.GetNoArena();
}
void RawHashes::set_raw_hashes(const ::std::string& value) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.raw_hashes)
}
#if LANG_CXX11
void RawHashes::set_raw_hashes(::std::string&& value) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.RawHashes.raw_hashes)
}
#endif
void RawHashes::set_raw_hashes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RawHashes.raw_hashes)
}
void RawHashes::set_raw_hashes(const void* value, size_t size) {
  set_has_raw_hashes();
  raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RawHashes.raw_hashes)
}
::std::string* RawHashes::mutable_raw_hashes() {
  set_has_raw_hashes();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RawHashes.raw_hashes)
  return raw_hashes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RawHashes::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.RawHashes.raw_hashes)
  clear_has_raw_hashes();
  return raw_hashes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RawHashes::set_allocated_raw_hashes(::std::string* raw_hashes) {
  if (raw_hashes != NULL) {
    set_has_raw_hashes();
  } else {
    clear_has_raw_hashes();
  }
  raw_hashes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_hashes);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RawHashes.raw_hashes)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RiceDeltaEncoding::kFirstValueFieldNumber;
const int RiceDeltaEncoding::kRiceParameterFieldNumber;
const int RiceDeltaEncoding::kNumEntriesFieldNumber;
const int RiceDeltaEncoding::kEncodedDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RiceDeltaEncoding::RiceDeltaEncoding()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}
RiceDeltaEncoding::RiceDeltaEncoding(const RiceDeltaEncoding& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  encoded_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_encoded_data()) {
    encoded_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.encoded_data_);
  }
  ::memcpy(&first_value_, &from.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_entries_) -
    reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}

void RiceDeltaEncoding::SharedCtor() {
  _cached_size_ = 0;
  encoded_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&first_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_entries_) -
      reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
}

RiceDeltaEncoding::~RiceDeltaEncoding() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RiceDeltaEncoding)
  SharedDtor();
}

void RiceDeltaEncoding::SharedDtor() {
  encoded_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RiceDeltaEncoding::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RiceDeltaEncoding& RiceDeltaEncoding::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

RiceDeltaEncoding* RiceDeltaEncoding::New(::google::protobuf::Arena* arena) const {
  RiceDeltaEncoding* n = new RiceDeltaEncoding;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RiceDeltaEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RiceDeltaEncoding)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_encoded_data()) {
    GOOGLE_DCHECK(!encoded_data_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*encoded_data_.UnsafeRawStringPointer())->clear();
  }
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 14u) {
    ::memset(&first_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_entries_) -
        reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RiceDeltaEncoding::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.RiceDeltaEncoding)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 first_value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_first_value();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &first_value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 rice_parameter = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_rice_parameter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rice_parameter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_entries = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_num_entries();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_entries_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes encoded_data = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encoded_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.RiceDeltaEncoding)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.RiceDeltaEncoding)
  return false;
#undef DO_
}

void RiceDeltaEncoding::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.RiceDeltaEncoding)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 first_value = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->first_value(), output);
  }

  // optional int32 rice_parameter = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rice_parameter(), output);
  }

  // optional int32 num_entries = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_entries(), output);
  }

  // optional bytes encoded_data = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->encoded_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.RiceDeltaEncoding)
}

size_t RiceDeltaEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RiceDeltaEncoding)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes encoded_data = 4;
    if (has_encoded_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encoded_data());
    }

    // optional int64 first_value = 1;
    if (has_first_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->first_value());
    }

    // optional int32 rice_parameter = 2;
    if (has_rice_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rice_parameter());
    }

    // optional int32 num_entries = 3;
    if (has_num_entries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_entries());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RiceDeltaEncoding::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RiceDeltaEncoding*>(&from));
}

void RiceDeltaEncoding::MergeFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_encoded_data();
      encoded_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.encoded_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      first_value_ = from.first_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      rice_parameter_ = from.rice_parameter_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_entries_ = from.num_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RiceDeltaEncoding::CopyFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoding::IsInitialized() const {
  return true;
}

void RiceDeltaEncoding::Swap(RiceDeltaEncoding* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RiceDeltaEncoding::InternalSwap(RiceDeltaEncoding* other) {
  using std::swap;
  encoded_data_.Swap(&other->encoded_data_);
  swap(first_value_, other->first_value_);
  swap(rice_parameter_, other->rice_parameter_);
  swap(num_entries_, other->num_entries_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RiceDeltaEncoding::GetTypeName() const {
  return "mozilla.safebrowsing.RiceDeltaEncoding";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RiceDeltaEncoding

// optional int64 first_value = 1;
bool RiceDeltaEncoding::has_first_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RiceDeltaEncoding::set_has_first_value() {
  _has_bits_[0] |= 0x00000002u;
}
void RiceDeltaEncoding::clear_has_first_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void RiceDeltaEncoding::clear_first_value() {
  first_value_ = GOOGLE_LONGLONG(0);
  clear_has_first_value();
}
::google::protobuf::int64 RiceDeltaEncoding::first_value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
  return first_value_;
}
void RiceDeltaEncoding::set_first_value(::google::protobuf::int64 value) {
  set_has_first_value();
  first_value_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
bool RiceDeltaEncoding::has_rice_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RiceDeltaEncoding::set_has_rice_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
void RiceDeltaEncoding::clear_has_rice_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
void RiceDeltaEncoding::clear_rice_parameter() {
  rice_parameter_ = 0;
  clear_has_rice_parameter();
}
::google::protobuf::int32 RiceDeltaEncoding::rice_parameter() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
  return rice_parameter_;
}
void RiceDeltaEncoding::set_rice_parameter(::google::protobuf::int32 value) {
  set_has_rice_parameter();
  rice_parameter_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
bool RiceDeltaEncoding::has_num_entries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RiceDeltaEncoding::set_has_num_entries() {
  _has_bits_[0] |= 0x00000008u;
}
void RiceDeltaEncoding::clear_has_num_entries() {
  _has_bits_[0] &= ~0x00000008u;
}
void RiceDeltaEncoding::clear_num_entries() {
  num_entries_ = 0;
  clear_has_num_entries();
}
::google::protobuf::int32 RiceDeltaEncoding::num_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
  return num_entries_;
}
void RiceDeltaEncoding::set_num_entries(::google::protobuf::int32 value) {
  set_has_num_entries();
  num_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
bool RiceDeltaEncoding::has_encoded_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RiceDeltaEncoding::set_has_encoded_data() {
  _has_bits_[0] |= 0x00000001u;
}
void RiceDeltaEncoding::clear_has_encoded_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void RiceDeltaEncoding::clear_encoded_data() {
  encoded_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encoded_data();
}
const ::std::string& RiceDeltaEncoding::encoded_data() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.GetNoArena();
}
void RiceDeltaEncoding::set_encoded_data(const ::std::string& value) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
#if LANG_CXX11
void RiceDeltaEncoding::set_encoded_data(::std::string&& value) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
#endif
void RiceDeltaEncoding::set_encoded_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
void RiceDeltaEncoding::set_encoded_data(const void* value, size_t size) {
  set_has_encoded_data();
  encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
::std::string* RiceDeltaEncoding::mutable_encoded_data() {
  set_has_encoded_data();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RiceDeltaEncoding::release_encoded_data() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  clear_has_encoded_data();
  return encoded_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RiceDeltaEncoding::set_allocated_encoded_data(::std::string* encoded_data) {
  if (encoded_data != NULL) {
    set_has_encoded_data();
  } else {
    clear_has_encoded_data();
  }
  encoded_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoded_data);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntryMetadata_MetadataEntry::kKeyFieldNumber;
const int ThreatEntryMetadata_MetadataEntry::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}
ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}

void ThreatEntryMetadata_MetadataEntry::SharedCtor() {
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ThreatEntryMetadata_MetadataEntry::~ThreatEntryMetadata_MetadataEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  SharedDtor();
}

void ThreatEntryMetadata_MetadataEntry::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ThreatEntryMetadata_MetadataEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata_MetadataEntry::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata_MetadataEntry::New(::google::protobuf::Arena* arena) const {
  ThreatEntryMetadata_MetadataEntry* n = new ThreatEntryMetadata_MetadataEntry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatEntryMetadata_MetadataEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*key_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!value_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*value_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatEntryMetadata_MetadataEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes value = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  return false;
#undef DO_
}

void ThreatEntryMetadata_MetadataEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->value(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}

size_t ThreatEntryMetadata_MetadataEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional bytes value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatEntryMetadata_MetadataEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatEntryMetadata_MetadataEntry*>(&from));
}

void ThreatEntryMetadata_MetadataEntry::MergeFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
}

void ThreatEntryMetadata_MetadataEntry::CopyFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata_MetadataEntry::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata_MetadataEntry::Swap(ThreatEntryMetadata_MetadataEntry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatEntryMetadata_MetadataEntry::InternalSwap(ThreatEntryMetadata_MetadataEntry* other) {
  using std::swap;
  key_.Swap(&other->key_);
  value_.Swap(&other->value_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntryMetadata_MetadataEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
bool ThreatEntryMetadata_MetadataEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntryMetadata_MetadataEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatEntryMetadata_MetadataEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntryMetadata_MetadataEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
const ::std::string& ThreatEntryMetadata_MetadataEntry::key() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.GetNoArena();
}
void ThreatEntryMetadata_MetadataEntry::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
#if LANG_CXX11
void ThreatEntryMetadata_MetadataEntry::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
#endif
void ThreatEntryMetadata_MetadataEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
void ThreatEntryMetadata_MetadataEntry::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
::std::string* ThreatEntryMetadata_MetadataEntry::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntryMetadata_MetadataEntry::release_key() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
bool ThreatEntryMetadata_MetadataEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntryMetadata_MetadataEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatEntryMetadata_MetadataEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntryMetadata_MetadataEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
const ::std::string& ThreatEntryMetadata_MetadataEntry::value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.GetNoArena();
}
void ThreatEntryMetadata_MetadataEntry::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
#if LANG_CXX11
void ThreatEntryMetadata_MetadataEntry::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
#endif
void ThreatEntryMetadata_MetadataEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
void ThreatEntryMetadata_MetadataEntry::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
::std::string* ThreatEntryMetadata_MetadataEntry::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntryMetadata_MetadataEntry::release_value() {
  // @@protoc_insertion_point(field_release:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntryMetadata::kEntriesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntryMetadata::ThreatEntryMetadata()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}
ThreatEntryMetadata::ThreatEntryMetadata(const ThreatEntryMetadata& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}

void ThreatEntryMetadata::SharedCtor() {
  _cached_size_ = 0;
}

ThreatEntryMetadata::~ThreatEntryMetadata() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata)
  SharedDtor();
}

void ThreatEntryMetadata::SharedDtor() {
}

void ThreatEntryMetadata::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntryMetadata& ThreatEntryMetadata::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatEntryMetadata* ThreatEntryMetadata::New(::google::protobuf::Arena* arena) const {
  ThreatEntryMetadata* n = new ThreatEntryMetadata;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatEntryMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatEntryMetadata)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatEntryMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatEntryMetadata)
  return false;
#undef DO_
}

void ThreatEntryMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatEntryMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->entries_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->entries(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatEntryMetadata)
}

size_t ThreatEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->entries_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->entries(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatEntryMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatEntryMetadata*>(&from));
}

void ThreatEntryMetadata::MergeFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
}

void ThreatEntryMetadata::CopyFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata::Swap(ThreatEntryMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatEntryMetadata::InternalSwap(ThreatEntryMetadata* other) {
  using std::swap;
  entries_.InternalSwap(&other->entries_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntryMetadata::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntryMetadata

// repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
int ThreatEntryMetadata::entries_size() const {
  return entries_.size();
}
void ThreatEntryMetadata::clear_entries() {
  entries_.Clear();
}
const ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Get(index);
}
::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Mutable(index);
}
::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >*
ThreatEntryMetadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return &entries_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >&
ThreatEntryMetadata::entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatListDescriptor::kThreatTypeFieldNumber;
const int ThreatListDescriptor::kPlatformTypeFieldNumber;
const int ThreatListDescriptor::kThreatEntryTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatListDescriptor::ThreatListDescriptor()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatListDescriptor)
}
ThreatListDescriptor::ThreatListDescriptor(const ThreatListDescriptor& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatListDescriptor)
}

void ThreatListDescriptor::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&threat_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
}

ThreatListDescriptor::~ThreatListDescriptor() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatListDescriptor)
  SharedDtor();
}

void ThreatListDescriptor::SharedDtor() {
}

void ThreatListDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatListDescriptor& ThreatListDescriptor::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ThreatListDescriptor* ThreatListDescriptor::New(::google::protobuf::Arena* arena) const {
  ThreatListDescriptor* n = new ThreatListDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreatListDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatListDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ThreatListDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ThreatListDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatType_IsValid(value)) {
            set_threat_type(static_cast< ::mozilla::safebrowsing::ThreatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::PlatformType_IsValid(value)) {
            set_platform_type(static_cast< ::mozilla::safebrowsing::PlatformType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mozilla::safebrowsing::ThreatEntryType_IsValid(value)) {
            set_threat_entry_type(static_cast< ::mozilla::safebrowsing::ThreatEntryType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ThreatListDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ThreatListDescriptor)
  return false;
#undef DO_
}

void ThreatListDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ThreatListDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->threat_type(), output);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->platform_type(), output);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->threat_entry_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ThreatListDescriptor)
}

size_t ThreatListDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatListDescriptor)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
    if (has_threat_entry_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreatListDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreatListDescriptor*>(&from));
}

void ThreatListDescriptor::MergeFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatListDescriptor::CopyFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatListDescriptor::IsInitialized() const {
  return true;
}

void ThreatListDescriptor::Swap(ThreatListDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreatListDescriptor::InternalSwap(ThreatListDescriptor* other) {
  using std::swap;
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatListDescriptor::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatListDescriptor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatListDescriptor

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
bool ThreatListDescriptor::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatListDescriptor::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreatListDescriptor::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreatListDescriptor::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
::mozilla::safebrowsing::ThreatType ThreatListDescriptor::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
void ThreatListDescriptor::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
bool ThreatListDescriptor::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatListDescriptor::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreatListDescriptor::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreatListDescriptor::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
::mozilla::safebrowsing::PlatformType ThreatListDescriptor::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
void ThreatListDescriptor::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
bool ThreatListDescriptor::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatListDescriptor::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreatListDescriptor::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreatListDescriptor::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
::mozilla::safebrowsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
void ThreatListDescriptor::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ListThreatListsResponse::kThreatListsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ListThreatListsResponse::ListThreatListsResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ListThreatListsResponse)
}
ListThreatListsResponse::ListThreatListsResponse(const ListThreatListsResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      threat_lists_(from.threat_lists_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ListThreatListsResponse)
}

void ListThreatListsResponse::SharedCtor() {
  _cached_size_ = 0;
}

ListThreatListsResponse::~ListThreatListsResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ListThreatListsResponse)
  SharedDtor();
}

void ListThreatListsResponse::SharedDtor() {
}

void ListThreatListsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ListThreatListsResponse& ListThreatListsResponse::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

ListThreatListsResponse* ListThreatListsResponse::New(::google::protobuf::Arena* arena) const {
  ListThreatListsResponse* n = new ListThreatListsResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ListThreatListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ListThreatListsResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_lists_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ListThreatListsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.ListThreatListsResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_threat_lists()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.ListThreatListsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.ListThreatListsResponse)
  return false;
#undef DO_
}

void ListThreatListsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.ListThreatListsResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->threat_lists_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->threat_lists(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.ListThreatListsResponse)
}

size_t ListThreatListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ListThreatListsResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->threat_lists_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->threat_lists(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ListThreatListsResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ListThreatListsResponse*>(&from));
}

void ListThreatListsResponse::MergeFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  threat_lists_.MergeFrom(from.threat_lists_);
}

void ListThreatListsResponse::CopyFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListThreatListsResponse::IsInitialized() const {
  return true;
}

void ListThreatListsResponse::Swap(ListThreatListsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ListThreatListsResponse::InternalSwap(ListThreatListsResponse* other) {
  using std::swap;
  threat_lists_.InternalSwap(&other->threat_lists_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ListThreatListsResponse::GetTypeName() const {
  return "mozilla.safebrowsing.ListThreatListsResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ListThreatListsResponse

// repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
int ListThreatListsResponse::threat_lists_size() const {
  return threat_lists_.size();
}
void ListThreatListsResponse::clear_threat_lists() {
  threat_lists_.Clear();
}
const ::mozilla::safebrowsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Get(index);
}
::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Mutable(index);
}
::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Add();
}
::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >*
ListThreatListsResponse::mutable_threat_lists() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return &threat_lists_;
}
const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >&
ListThreatListsResponse::threat_lists() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Duration::kSecondsFieldNumber;
const int Duration::kNanosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Duration::Duration()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_safebrowsing_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.Duration)
}
Duration::Duration(const Duration& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Duration)
}

void Duration::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nanos_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Duration::~Duration() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Duration)
  SharedDtor();
}

void Duration::SharedDtor() {
}

void Duration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Duration& Duration::default_instance() {
  protobuf_safebrowsing_2eproto::InitDefaults();
  return *internal_default_instance();
}

Duration* Duration::New(::google::protobuf::Arena* arena) const {
  Duration* n = new Duration;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Duration)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Duration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mozilla.safebrowsing.Duration)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 seconds = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_seconds();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seconds_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nanos = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_nanos();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nanos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mozilla.safebrowsing.Duration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mozilla.safebrowsing.Duration)
  return false;
#undef DO_
}

void Duration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mozilla.safebrowsing.Duration)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds(), output);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanos(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mozilla.safebrowsing.Duration)
}

size_t Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Duration)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional int64 seconds = 1;
    if (has_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->seconds());
    }

    // optional int32 nanos = 2;
    if (has_nanos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nanos());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Duration*>(&from));
}

void Duration::MergeFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Duration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Duration::CopyFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Duration::IsInitialized() const {
  return true;
}

void Duration::Swap(Duration* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Duration::InternalSwap(Duration* other) {
  using std::swap;
  swap(seconds_, other->seconds_);
  swap(nanos_, other->nanos_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Duration::GetTypeName() const {
  return "mozilla.safebrowsing.Duration";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Duration

// optional int64 seconds = 1;
bool Duration::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Duration::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
void Duration::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void Duration::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
  clear_has_seconds();
}
::google::protobuf::int64 Duration::seconds() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.seconds)
  return seconds_;
}
void Duration::set_seconds(::google::protobuf::int64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.seconds)
}

// optional int32 nanos = 2;
bool Duration::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Duration::set_has_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
void Duration::clear_has_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
void Duration::clear_nanos() {
  nanos_ = 0;
  clear_has_nanos();
}
::google::protobuf::int32 Duration::nanos() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.nanos)
  return nanos_;
}
void Duration::set_nanos(::google::protobuf::int32 value) {
  set_has_nanos();
  nanos_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.nanos)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace safebrowsing
}  // namespace mozilla

// @@protoc_insertion_point(global_scope)
