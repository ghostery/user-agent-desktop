/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "frontend/BCEScriptStencil.h"

#include "frontend/AbstractScopePtr.h"  // AbstractScope
#include "frontend/BytecodeEmitter.h"   // BytecodeEmitter
#include "frontend/BytecodeSection.h"   // BytecodeSection, PerScriptData
#include "vm/SharedStencil.h"

using namespace js;
using namespace js::frontend;

BCEScriptStencil::BCEScriptStencil(
    BytecodeEmitter& bce, UniquePtr<ImmutableScriptData> immutableScriptData)
    : ScriptStencil(bce.cx, std::move(immutableScriptData)), bce_(bce) {
  init();
}

void BCEScriptStencil::init() {
  lineno = bce_.firstLine;
  column = bce_.firstColumn;

  natoms = bce_.perScriptData().atomIndices()->count();

  ngcthings = bce_.perScriptData().gcThingList().length();

  immutableFlags = bce_.sc->immutableFlags();

  // Update the flags generated by BCE.
  immutableFlags.setFlag(ImmutableScriptFlagsEnum::Strict, bce_.sc->strict());
  immutableFlags.setFlag(
      ImmutableScriptFlagsEnum::NeedsFunctionEnvironmentObjects,
      getNeedsFunctionEnvironmentObjects());
  immutableFlags.setFlag(
      ImmutableScriptFlagsEnum::HasNonSyntacticScope,
      bce_.outermostScope().hasOnChain(ScopeKind::NonSyntactic));

  gcThings = bce_.perScriptData().gcThingList().stealGCThings();

  // Update flags specific to functions.
  if (isFunction()) {
    FunctionBox* funbox = bce_.sc->asFunctionBox();
    functionIndex.emplace(funbox->index());

    // Set flags that don't have direct flag representation within the
    // FunctionBox.
    immutableFlags.setFlag(ImmutableScriptFlagsEnum::HasMappedArgsObj,
                           funbox->hasMappedArgsObj());
    immutableFlags.setFlag(
        ImmutableScriptFlagsEnum::FunctionHasExtraBodyVarScope,
        funbox->hasExtraBodyVarScope());
  } /* isFunctionBox */
}

bool BCEScriptStencil::getNeedsFunctionEnvironmentObjects() const {
  // See JSFunction::needsCallObject()
  js::AbstractScopePtr bodyScope = bce_.bodyScope();
  if (bodyScope.kind() == js::ScopeKind::Function) {
    if (bodyScope.hasEnvironment()) {
      return true;
    }
  }

  // See JSScript::maybeNamedLambdaScope()
  js::AbstractScopePtr outerScope = bce_.outermostScope();
  if (outerScope.kind() == js::ScopeKind::NamedLambda ||
      outerScope.kind() == js::ScopeKind::StrictNamedLambda) {
    MOZ_ASSERT(bce_.sc->asFunctionBox()->isNamedLambda());

    if (outerScope.hasEnvironment()) {
      return true;
    }
  }

  return false;
}

bool BCEScriptStencil::finishGCThings(
    JSContext* cx, mozilla::Span<JS::GCCellPtr> output) const {
  return EmitScriptThingsVector(cx, bce_.compilationInfo, gcThings, output);
}

void BCEScriptStencil::initAtomMap(GCPtrAtom* atoms) const {
  const AtomIndexMap& indices = *bce_.perScriptData().atomIndices();

  for (AtomIndexMap::Range r = indices.all(); !r.empty(); r.popFront()) {
    JSAtom* atom = r.front().key();
    uint32_t index = r.front().value();
    MOZ_ASSERT(index < indices.count());
    atoms[index].init(atom);
  }
}

void BCEScriptStencil::finishInnerFunctions() const {
  bce_.perScriptData().gcThingList().finishInnerFunctions();
}
